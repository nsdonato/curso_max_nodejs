# Sección 1 - Introduction
    Introduction
    What is Node.js?
        
        Runtime
        JS: 
            tipicalmente lo usas en el navegador para manipular el dom.
        Node js: 
            escrito en javascript, te habilita a correr javascript en el servidor, como cualquier otro lenguaje de programación.
            V8, es la maquina de javascript que corre javascript en el navegador, o sea es compilado en lenguaje de maquina.
            O sea, con node js, podes agregar funcionalidad al engine V8, para acceder por ej a archivos.


    Installing Node.js and Creating our First App

        - Crea una carpeta
        - crea un archivo first-app.js
        - enseña como usar fs, o sea, requerirlo para tener acceso al file sistem
            ej: 
                const fs = require('fs');

                fs.writeFileSync('hello.txt', "Hola mundo!");

    Understanding the Role & Usage of Node.js
        
        Explica como el usuario hace una petición, se le devuelven archivos, y aparte con node js, se accede a base de datos, se puede autenticar en otros sitios con oauth, validar inputs, logica de negocio etc.
        Comenta que se puede hacer para hacer mas cosas que esto, scripts, compilar herramientas, etc.

        Se pude crear un servidor que responde a request entrantes, trabajar con db, archivos, etc.
        Responder html, json, xml, archivos, etc.

        Python, PHP, DJIANGO, net core, ETC, son una alternativa a Node js

    Course Outline

        Habla de lo que va del curso, lo saltee, habla de todo eso que se ve en la pantalla.

    How To Get The Most Out Of The Course

        Como sacarle provecho al crso...
            mirar los videos
            codificiar solo y hacer los ejercicios...
            usar los recursos que estan en el curso
            hacer preguntas
            ayudar a otros que hacen preguntas

    Working with the REPL vs Using FIles

        R ead (leer el input del usuario)
        E val (evaluar el input del usuario)
        P rint (output result)
        L oop (esperar por el input)
        
            ejecutar codigo que escribiste
            pa jugar
        vs

        Files:
            usado para hacer aplicaciones reales
            secuencia de pasos.

    Using the Attached Source Code
        
        Explica como usar el codigo que viene en el curso, en ingles, es solo ste texto:

            Using the Attached Source Code
            Sección 1, Clase 8
            Throughout this course, we'll write a lot of code. And to give you the possibility of comparing your code to mine (to find + fix potential errors in your code), you'll find multiple code snapshots per module attached to lectures in this course.

            The last lecture of each module always holds all snapshots for the module, ordered chronologically.

            You can view the code and compare it to yours or replace (parts of) your code with it temporarily (to narrow down the issue).

            How do you use the attached code?

            BEFORE we started using npm, you simply run the main .js file via node - just as we do it in the videos. Or you simply look into the code files to view + compare the code.

            AFTER we started using npm, you need to run npm install inside of the extracted code attachment before you can run npm start to run the server.

------------------------------------------------------------------

# Sección 2 - Optional: JavaScript - A Quick Refresher
    
    Module Introduction
    JavaScript in a Nutshell
    Refreshing the Core Syntax
    let & const
    Understanding Arrow Functions
    Working with Objects, Properties & Methods
    Arrays & Array Methods
    Arrays, Objects & Reference Types
    Understanding Spread & Rest Operators
    Destructuring
    Async Code & Promises
    Template Literals
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Sección 3 - Understanding the Basics

    Module Introduction

        Como funciona la Web
        Crear un servidor con node js
        usando los modulos core de Nore
        trabajar con request y response        
        codigo asincrono y "the event loop"

    How The Web Works

        Usuario/Cliente (Request) -> 
            Navegador -> 
                entra a una url -> 
                    se busca ese sitio en internet a través de su nombre de dominio ->
                        Tu pagina ( tu codigo )
                            hecho en node js, php, asp .net etc
                            se conecta a base de datos bla.

                        <- Responde tu sitio con headers, html, etc.

        Todo esto se realiza utilizando los protocolos 
        
        HTTP
            Hyper Text Transfer Protocol.
                Como se muestran los request, devuelve las paginas, etc.

        HTTPS
            Hyper Text Transfer Protocol Secure
                HTTP + Data encriptada (durante la transmisión)
                    Para que tu información este segura y estes seguro que nadie este robando la info etc.

    Creating a Node Server
        
        Modulos Core 
            
            http
                Lanza un servidor, envia request, comunicación entre servidores, etc
            https
                Lanza un servior con SSL
            fs
                manejo de archivos
            path
                nos ayuda a manejar los archivos de la solución, o sea la ruta ./ y demas
            os
                nos ayuda con el manejo del sistema operativo.

        Creación del archivo app.js, para crear el servidor en node, con HTTP.

        // Creamos app.js para crear el servidr con node js
        app.js
            const http = require('http'); // Busca por un modulo global llamado http, si hubiera un archivo http, no lo levantaría.
            // import http from 'http'; esto no funciona al menos en la archivo que inicia el servidor.


            const server = http.createServer((req,resp) => {
                console.log(req);
            }); // Va a llamar a la función anonima, para cada request entrante.

            // Le tenemos que decir que escuche, los request entrantes, en un puerto determinado
            server.listen(3000, () => {
                console.log("Servidor corriendo en el puerto: 3000");
            });

    The Node Lifecycle & Event Loop

        node app.js -> 
            start script -> 
                parsea el codigo, registra las variables y funciones ->
                    Se mantiene a la escucha hasta que finalicemos la ejecución del servidor. (Mediante el loop de evento)

        //process.exit(); // Podríamos utilizar esto apra terminar el proceso, pero no tiene sentido stopear un servidor web.

    Controlling the Node.js Process

        Want to quit your running Node.js server?
        You can always do that by pressing CTRL + C in the terminal/ command prompt window where you started your server (i.e. where you ran node app.js).

    Understanding Requests

        console.log(req), vemos Metadatos informados en el request.
            host... headers agregados por el usuario en el request, etc.
            info de cookies, entre mil cosas.


        console.log(req.url);
        console.log(req.method);
        console.log(req.headers);
            GET
            { host: 'localhost:3000',
            connection: 'keep-alive',
            'upgrade-insecure-requests': '1',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',
            accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
            'accept-encoding': 'gzip, deflate, br',
            'accept-language': 'es',
            cookie: '__utmz=111872281.1548878903.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _ga=GA1.1.270523245.1548878903; __utma=111872281.270523245.1548878903.1548878903.1550705859.2' }
            
        La url es cualquier cosa después de nuestro host, o sea después de la ip (hablando localmente)

    Sending Responses

        response.setHeader('Content-Type','text/html'); // Setea el tipo de respuesta que va a devolver.
        response.write('<html>'); // Escribe multiples lineas de información
        response.write('<head><title>Mi primer pagina</title></head>'); // Escribe multiples lineas de información
        response.write('<body><h1>Hola Mundo</h1></body>'); // Escribe multiples lineas de información
        response.write('</html>'); // Escribe multiples lineas de información
        response.end();

    Request & Response Headers

        On both requests and responses, Http headers are added to transport metadata from A to B.

        The following article provides a great overview of available headers and their role: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers

        Whilst this article is a great resource, especially to dive deeper, please don't learn this list by heart though! You'll encounter many of these headers throughout the course and I'll explain them when we need them.

        
    Routing Requests

        app.js
            const url = request.url;

            if(url === '/'){
                response.write('<html>'); // Escribe multiples lineas de información
                response.write('<head><title>Ingrese un mensaje</title></head>'); // Escribe multiples lineas de información
                response.write('<body><form action="/mensaje" method="POST"><input type="text"><button type="submit">ENVIAR</button></body>'); // Escribe multiples lineas de información
                response.write('</html>'); // Escribe multiples lineas de información
                return response.end(); // El return es para no continuar con la ejecución del codigo
            }

    Redirecting Requests

        app.js
            if(url === '/mensaje' && method === 'POST'){
                
                fs.writeFileSync('mensaje.txt','DUMMY');
                res.statusCode = 302;
                res.setHeader('Location', '/');
                return res.end();
            }

    Parsing Request Bodies
    
        Los datos que vienen por request, son enviados como una "corriente" stream, de datos.
        => Buffer:
            Ej: request incoming ->
                Stream -> info enviada en partes -> Full parsed

            Para organizar estos pedazos de información que vienen de a partes, se usa el buffer.
            El BUFFER es una construcción que te permite trabajar con los multiples pedazos de información antes de ser liberados.

               if(url === '/mensaje' && method === 'POST'){
        
                    // Para trabajar con los pedazos de información que van llegando, 
                    // utilizamos metodos como on, que nos permite escuchar diferentes eventos, en este caso el evento data.
                    const body = [];
                    // El evento data se dispara cuando un nuevo pedazo de información esta listo para ser leido.
                    req.on('data', (chunk) => {
                        console.log(chunk);
                        body.push(); // Pusheamos info en el body;
                    });
                    
                    // Escuchamos el evento end, una vez que se termine de parsear los pedazos de datas del request
                    req.on('end', () => {
                        // Trabajar con el buffer mediante el objeto Buffer que nos provee _Node Js.
                        const parsedBody =  Buffer.concat(body).toString();
                        const mensaje = parsedBody.split('=')[1];
                        fs.writeFileSync('mensaje.txt',mensaje);
                    });

                    //fs.writeFileSync('mensaje.txt','DUMMY');
                    res.statusCode = 302;
                    res.setHeader('Location', '/');
                    return res.end();
            }

    Understanding Event Driven Code Execution

        Explica el orden en el que se   ejecuta el codigo Node js...

    Blocking and Non-Blocking Code

        // Es sincronico, así que bloquea las siguientes ejecuciones.
            fs.writeFileSync('archivo.txt', mensaje);

       // Asincronico 
            fs.writeFile('mensaje.txt', mensaje, (err) => {
                // Deberíamos usar este para leer un archivo grande.
                //fs.writeFileSync('mensaje.txt','DUMMY');
                res.statusCode = 302;
                res.setHeader('Location', '/');
                return res.end();
            });

    Node.js - Looking Behind the Scenes

        Explica que pasa detras de escena.

        Node JS, usa un solo hilo JavaScript (para todos los request)
        
        * VER OTRA VEZ. Lo pase..

    Using the Node Modules System

        Corta todo lo que es de ruteo que estaba en app.js y lo pone en routes.js
        Explica como exportar el modulo y utilizarlo desde otro archivo.

        1) module.exports = nombrefuncion; // puede ser función o un objeto que contenga otros objetos con diferntes cosas.
        2) Shortcut: 
            exports = nombreFuncion;


        routes.js
            EJ 1:
                const requestHandler = (req, res) => {
                    // codigo
                }
                module.exports = requestHandler;

            EJ 2:
                module.exports = {
                    handler: requestHandler,
                    someText: 'Hola soy un texto'
                }

            EJ 3:
                module.exports.handler = requestHandler;
                module.exports.someText =  'Hola soy un texto';

        app.js
            EJ 1:
                const http = require('http'); // Busca por un modulo global llamado http, si hubiera un archivo http, no lo levantaría.
                const routes = require('./routes'); // Como no es un modulo global hay que buscarlo entre los archivos.

                const server = http.createServer(routes); // Maneja a traves de routes, los request entrantes.

            EJ 2:
                const server = http.createServer(routes.handler);
                console.log(routes.someText);

    Wrap Up

        Resumen de todo el modulo.
        
    Time to Practice - The Basics 
        /*
        Tarea:

        1. Levantar un Servidor en el puerto 3000
        2. Manejar 2 rutas "/" y "/usuarios"
            - Devolver algun saludo de bienvenida en /
            - Devolver una lista dummy de usuarios <ul><li>Usuario 1</li><li>Usuario 2</li></ul>
        3. Agregar un formulario con un input username acción / y un boton de submit, metodo POST -> /crear-usuario en el boton
        4. Crear la ruta /crear-usuario y parsear la info entrante, o sea, el username y loguearlo en la consola.

        */

        La hice :)

    Useful Resources & Links

        Attached, you find the source code for this section.

        Useful resources:

        Official Node.js Docs: https://nodejs.org/en/docs/guides/

        Full Node.js Reference (for all core modules): https://nodejs.org/dist/latest/docs/api/

        More about the Node.js Event Loop: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/

        Blocking and Non-Blocking Code: https://nodejs.org/en/docs/guides/dont-block-the-event-loop/

        Recursos de esta clase
        01-routing-requests.zip
        02-parsing-request-bodies.zip
        03-blocking-and-non-blocking-code.zip
        Ver más (3)
------------------------------------------------------------------

# Sección 4 - Improved Development Workflow and Debugging

    Module Introduction
    Understanding NPM Scripts

        npm.org
        1) > npm init
            llenarlo y por ultimo: yes

        2) package.json
            en scripts, agregar start.
            "start": "node app.js"
        
        3) > npm start // para ejecutar ese script

    Installing 3rd Party Packages

        1) Instalar paquetes de 3ros
        2) > npm install nodemon --save-dev
            -g para instalarla globalmente y usarla en todos los repos
            --save-dev // Para que se guarde como dependencia de desarrollo
        3) 
    
    Global Features vs Core Modules vs Third-Party Modules

        The last lectures contained important concepts about available Node.js features and how to unlock them.

        You can basically differentiate between:

        Global features: 
            Keywords like const or function but also some global objects like process

        Core Node.js Modules: 
            Examples would be the file-system module ("fs"), the path module ("path") or the Http module ("http")

        Third-party Modules: 
            Installed via npm install - you can add any kind of feature to your app via this way

        Global features are always available, you don't need to import them into the files where you want to use them.

        Core Node.js Modules don't need to be installed (NO npm install is required) but you need to import them when you want to use features exposed by them.

        Example:

            const fs = require('fs');

            You can now use the fs object exported by the "fs" module.
            Third-party Modules need to be installed (via npm install in the project folder) AND imported.
            
            Example (which you don't need to understand yet - we'll cover this later in the course):

            // In terminal/ command prompt
                npm install --save express-session
            
            // In code file (e.g. app.js)
                const sessions = require('express-session');

    Using Nodemon for Autorestarts

        Explica como funciona nodemon..

    Global & Local npm Packages

        In the last lecture, we added nodemon as a local dependency to our project.

        The good thing about local dependencies is that you can share projects without the node_modules folder (where they are stored) and you can run npm install in a project to then re-create that node_modules folder. This allows you to share only your source code, hence reducing the size of the shared project vastly.

        The attached course code snippets also are shared in that way, hence you need to run npm install in the extracted packages to be able to run my code!

        I showed that nodemon app.js would not work in the terminal or command line because we don't use local dependencies there but global packages.

        You could install nodemon globally if you wanted (this is NOT required though - because we can just run it locally): npm install -g nodemon would do the trick. Specifically the -g flag ensures that the package gets added as a global package which you now can use anywhere on your machine, directly from inside the terminal or command prompt.

    Understanding different Error Types

        Errores de sintaxis
            Cuando le pifias a un ; o lo que sea, se te marca en rojo al toque en el IDE
        
        Errores de compilación
            Cuando se rompe codigo al compilar
        
        Errores Logicos
            No ves un mensaje de error, y son dificles de encontrar
    
    Finding & Fixing Syntax Errors

        Si bien se ven en rojo en la pantalla, también te podes dar cuenta cuando compilas y te dice el error donde esta..

    Dealing with Runtime Errors

        Errores por los cuales por ej, el codigo sigue a una parte que no tenia que seguir.. etc
        También se pueden ver cuando compilas la aplicación

    Logical Errors

        Explica que hay errores que no saltan y te podes volver loco buscandolos, como poner mal un indice bla.
        Explica también un poco de como debugear..

    Using the Debugger

       Explica como usar el debug

    Restarting the Debugger Automatically After Editing our App

          Depurar > Abrir configuraciones

            "program": "${workspaceFolder}\\app.js", // Para que siempre arranque a debuggear desde app
            "restart": true,
            "runtimeExecutable": "nodemon",
            "console": "integratedTerminal"

        Esto sirve para que también se restartee cuando estes debugeando y cambiaste algo.
        Si da error es porque no habíamos instalao nodemon globalmente. 

    Debugging Node.js in Visual Studio Code
    
        Want to dive super-deep into the latest debugging capabilities Visual Studio Code gives you (for Node.js apps)?

        This article will be very helpful: https://code.visualstudio.com/docs/nodejs/nodejs-debugging
        
    
    
    Changing Variables in the Debug Console
    
        Muestra como cambiar una variable en Visual Studio Code, sobretodo como cambiar las constantes.
    
    Wrap Up
        Resumen del modulo.
    Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        More on debugging Node.js: https://nodejs.org/en/docs/guides/debugging-getting-started/

        Debugging Node in Visual Studio Code: https://code.visualstudio.com/docs/nodejs/nodejs-debugging

        Recursos de esta clase
        01-understanding-npm-scripts.zip
        02-using-nodemon-for-autorestarts.zip
        03-finished.zip

------------------------------------------------------------------

# Sección 5 - Working with Express.js

    Module Introduction
    What is Express.js?

        Es un framework:
            Funciones de ayuda, herramientas, reglas que te ayudan a contruir tu aplicación.

        Como escribir logica de servidor es compleja, express simplifica esto (lo del buffer x ej)}
        Enforcarnos en lo que realmente importa, como logica de negocios, etc.

        Alternativas a Express:
            Vanilla Node.js (lo que enseñó al principio)
            Adonis.js
            Koa
            Sails.js
            ...

    Installing Express.js

        > npm install express --save // Para instalar en prod

        const express = require('express');

        // Creamos una aplicación y la guardamos en una constante para correr express como una función
        const app = express();

    Adding Middleware

        Middleware:
            Significa que todos los request automaticamente son canalizados a traves de estas funciones por express.
        
        app.use nos permite agregar middleare
 
            app.use((req,res,next) =>{
                // req = request
                // res = response
                // next = ir al siguiente middleware
                
                // console.log("Middleware 1");
                // next();
            });

            // app.use((req,res,next) =>{
            //     console.log("Middleware 2");
            //     //next();
            // });

    How Middleware Works

        res.send('<h1>Hola desde Express</h1>'); // Envia una respuesta
        Por defecto el tipo de respuesta es text/html
    
    Express.js - Looking Behind the Scenes

        Muestra el codigo de Express en Github
        app.list(puerto)
        
    Handling Different Routes
    
        Como rutear con Express.
        Siempre tienen que ir las personalizadas antes que la / porque sino nunca entrarían en esas..
        SALVO QUE SE PONGA NEXT.

    Time to Practice - Express.js 

        Tarea 2:

        1. Crear un proyecto npm e instalar express y nodemon, si queres..
        2. Crear una aplicación express, que tenga 2 request canalizados con middleare que logueen algo en la consola y al menos uno retorne algo
        3. Manejar request para / y /usuarios que cada uno tenga al menos un handler/middleare que haga algo como enviar response dummy


    Parsing Incoming Requests
    
        Por defecto el body no se parsea, es por esto que se usa body-parser

        const bodyParser = require('body-parser');
        
        // urlencoded parsea lo que viene por queryString, no json, para eso se necesita otro.
        // Hay que configurarlo para habilitarlo o no con features especiales.
        app.use(bodyParser.urlencoded({ extended: false}));

        Se obtiene clave/valor.

    Limiting Middleware Execution to POST Requests
    
        En vez de usar app.use se usa:
             app.get
             app.post
             app.put
             app.patch
             ...
             
    Using Express Router
    
        app.js
            const adminRoutes = require('./routes/admin');
            const shopRoutes = require('./routes/shop');

            app.use(adminRoutes);
            app.use(shopRoutes);
        
        admin.js
            const express = require('express');
            const router = express.Router();

            router.get("/add-producto", (req,res) =>{
                //console.log('En otro middleware');
                res.send('<form action="/producto" method="POST"><input type="text" name="title"><button type="submit">Add Product</button></form>'); // Envia una respuesta
            });

            router.post("/producto", (req,res) =>{
                console.log(req.body);
                res.redirect('/');
            });

            module.exports = router;

        shop.js
            const express = require('express');
            const router = express.Router();

            app.use("/", (req,res,next) =>{
                res.send('<h1>Hola desde Express</h1>'); // Envia una respuesta
            });

            module.exports = router;

    Adding a 404 Error Page

        Se agrega la ruta para la pag 404

    Filtering Paths

        Para que los archivos de ruteo no se llmen directamentes así en el navegador:
            ttp://localhost:3000/add-producto
        Sino1:
            http://localhost:3000/admin/add-producto

        app.use('/admin',adminRoutes);
        app.use('/shop',shopRoutes);
    
    Creating HTML Pages
    
        Crear la carpeta views, donde van a estar las vistas de nuestra app
    
    Serving HTML Pages

        shop.js
            const path = require('path');
            res.sendfile( path.join(__dirname, '../','views','shop.html'));

        Returning a 404 Page

            Crea 404.html
            modifica en app: res.status(404).sendFile(path.join(__dirname, 'views', '404.html'));
        
        Using a Helper Function for Navigation

            path.dirname // Retorna el nombre del directorio
            process.mainModule // Se refiere a la ruta principal que arranca la app

        utils/path.js
            const path = require('path');
            module.exports = path.dirname(process.mainModule.filename);

    Styling our Pages
    
        Averiguar que es CSS bem
            Algo asi como, una manera de nomenclar las clases para que no haya repetidas.

    
    Serving Files Statically
    
        crea la carpeta public
        Agregamos a uno de los html:
            <link rel="stylesheet" href="/css/main.css">
        
        app.js
            // Servimos los archivos estaticos a la carpeta public
            app.use(express.static(path.join(__dirname,'public')));

    
    Time to Practice - Navigation 
    
        Tarea 3:

            1. Crear un proyecto npm, instalar Express y Nodemon
            2. Crear un archivo app.js que sirva 2 archivos html (de tu elección con tu contenido)
            3. Agregar algún archivo estatico, css o js al proyecto y que sea requerido en alguno de los archivos html.

            // TO DO
            TAREA PENDIENTE.

    Wrap Up
        Resumen del curso

    Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Express.js Official Docs: https://expressjs.com/en/starter/installing.html

        Recursos de esta clase
        01-adding-middleware.zip
        02-looking-behind-the-scenes.zip
        03-handling-different-routes.zip
        Ver más (11)

------------------------------------------------------------------

# Sección 6 - Working with Dynamic Content & Adding Templating Engines

    Module Introduction
    Sharing Data Across Requests & Users
    
        Importar un modulo en otro, para obtener info, ej de adminData -> productos
    
    Templating Engines - An Overview

        HTMLish Template
            HTML
        
        Node/Express Contenido | Maquinas de Templates
            que entienden data como la de productos y la convierten a html 

        Todo esto se compila en el servidor generando un archivo HTML.

        Gratis:
            EJS 
                - Normal HTML y JavaScript plano en los templates
                <p> <%= name %></p>
                
            Pug(Jade) 
                - Use minimal HTML y un lenguaje de template customizado
                p #{name}

            Handlebars
                - Normal HTML y un lenguaje de template customizado
                <p>{{name}}</p>

    Installing & Implementing Pug
    
        - > npm install --save ejs pug express-handlebars
            express-handlebars -> usamos ese porque esta incorporado con Express

        - Los html se tienen que renombrar a .pug

        - Setear en el app que se va a usar un template. Esto no funciona tal cual para todos los templates.

            // Seteo con que template quiero trabajar
            app.set('view engine', 'pug');

            Si tuvieramos las vistas en una carpeta que no se llame views (default de express), deberíamos setearlo así:
            ej: app.use('views','folderVistas');

        shop.pug - Sintaxys
            <!DOCTYPE html>
            html(lang="en")
                head
                    meta(charset="UTF-8")
                    meta(name="viewport", content="width=device-width, initial-scale=1.0")
                    meta(http-equiv="X-UA-Compatible", content="ie=edge")
                    title Document
                body

        - el metodo render lo provee express y se usa para el template que seteamos
            // Le decimos el nombre de la vista y listo, ya que ya habíamos definido el nombre del template a usar.
            res.render('shop');


    Outputting Dynamic Content
    
        Para pasar info a la vista, desde el servidor:
            res.render('shop', { prods: products, docTitle: "Shop" });
        
        En la vista:
            #{docTitle}

            Para recorrer info como productos, pug tiene sus propias funciones 
                each prod in prods
            

    Official Pug Docs

        Want to learn more about Pug? Check out their official docs: https://pugjs.org/api/getting-started.html
    
    Converting HTML Files to Pug

        Hace el resto de los archivos que eran html, pug.
    
    Adding a Layout

        1) En la pagina layout, se ponen los bloques que se importan de cada vista correspondiente

        2) En cada "vista parcial", importa la vista layout, y genera los bloques que corresponden a la vista

            // De esta manera en la vista posta, se "importa" la vista layout
            extends layout/main-layout.pug
            
            // En este bloque se ponen los estilos correspondientes a la vista
            block styles
                link(rel="stylesheet", href="/css/main.css")
                link(rel="stylesheet", href="/css/product.css")
            
            // En este bloque se pone lo que realmente es de la vista.
            block content
                h1 Page Not Found

    Finishing the Pug Template
    
        Como marcar que vista es la activa en la navegación, considerando que ahora tenemos vistas parciales, layout..
            Le pasa el path, en su ruta, y valida eso por codigo, con javascript, que va dentro de parentesis.
                a(href="/shop", class="(path==='/shop' ? 'active' : '')) Shop

    Working with Handlebars
    
        app.engine('handlears',expressHbs());
        app.set('view engine', 'handlebars');

        // También se podría usar así, y así le pones también a las vistas:
        app.engine('hbs',expressHbs());
        app.set('view engine', 'hbs');
    

        En la vista las propiedades se usan así:
        {{ pageTitle }}
        
    Converting our Project to Handlebars
    
        if como este, no es soportado, se tiene que evaluar algo por true o false, 
        por ende esta validación hay que hacerla del lado del servidor y pasarla a la vista.
            {{#if prods.length > 0}}
                //...
            {{ else }}
                //...
            {{/if}}
        

            {{#each prods}}
                //...
                {{ this.title }}
            {{/each}}

        {{# if hasProductos }}

        Esto hace que la logica este del lado del servidor, almenos para handlebars debe trabajarse así, la vista es solo para mostrar cosas.

    
    Adding the Layout to Handlebars

         app.engine('hbs',expressHbs({ layoutsDir: 'views/layouts/',defaultLayout: 'main-layout'}));

         Handlebars no tiene lo que pug (en cuanto al block estilo), hay que poner un bloque if, como si fuera lo de active en pug..
         o sea, mandarselo a la vista y agregarlo si cumple con la condición.

         x ej lo de active se hace así:
            {{#if activeShop}}active{{/if}}

        Se usar para que no tome el layout x default
            en res.render('shop',{layout: false})

            Las vistas que tengna la info dentro de main, son las que van a ser embebidas en la vista layout en la aprte {{body}}

    Working with EJS
    
        No soporta layouts.

        <% if(prods.length > 0 %>

        <% for (let product of prods) { %>

        <% } %>
    Working on the Layout with Partials

         <%- include('includes/navigation.ejs') %>
         <%- include('includes/end.ejs') %>
         
    Wrap Up
    
        Resumen de todo..

    Time to Practice - Templating Engines 
    
        We learned a lot about Pug, Handlebars and EJS so let's see if we know how to use these templating engines now!
        
        Tarea 4: 

            1. Crear un proyecto npm, instalar Express y Nodemon
            2. Agregar 2 rutas:
                "/" -> Tiene un formulario que habilita al usuario a ingresar su nombre
                "/users" -> Tiene una lista con los nombres de usuarios (o algun texto de error)

            // TO DO
            TAREA PENDIENTE. No esuche el video solo anote lo que estaba en pantalla.


    Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Pug Docs: https://pugjs.org/api/getting-started.html

        Handlebars Docs: https://handlebarsjs.com/

        EJS Docs: http://ejs.co/#docs

        Recursos de esta clase
        00-starting-setup.zip
        01-sharing-data-across-requests-and-users.zip
        02-added-pug.zip
        Ver más (4)
------------------------------------------------------------------

# Sección 7 - The Model View Controller (MVC) - Sección 7
   
    92 - Module Introduction
    93 - What is the MVC?

        Se trata de una (separation of concerns) separación de preocupaciones.
        Te aseguras que las diferentes partes de tu código hagan cosas diferentes y usted sepa claramente qué parte es responsable de qué. 
        
        MVC significa modelo vista contrlador
        
        Models:
            Son objetos o parte de tu codigo responsable de representar los datos.
            Y te habilita a trabajar con los datos, x ej, guardar, pedir datos (api o bd o archivo)

        Views:
            Por lo que ve el usuario, y renderizar el contenido en el documento.
            Estan desacopladas de el cdigo de tu aplicación y solo tienen pequeños trozos de codigos, necesarios para que la información se muestre al usuario.

        Controladores:
            Son conectores entre el modelo y la vista, porque a la vista no le importa la logica de la aplicación y a los modelos les interesa acerca como guardar la info.
            Los controladores son los que trabajan con los modelos, guardando la información, etc.
            Los controladores son los que trabajan con las vistas, para tomar la información ingresada por el usuario y luego llamar al modelo para guardar.

            Es un intermediario que tiene logica intermediaria.

            También define con que modelo y vista se debe trabajar para hacer determinada acción.

        Rutas?: 
            Definen en que ruta encontrar tanto los metodos de los controladores como los metodos http que necesitamos

        
    94 - Adding Controllers
    
        A lo que se llama "logica intermediaria" del controlador, es a la parte del middlewareque se utiliza entre que se llama a la ruta necesaria y lo que retorna.
        Podes crear difrentes tipos de controladores, por ej adminController, productController, userController, y en cada uno manejar lo necesario para ese concepto.
        x ej, si bien antes habíamos puesto /shop por otro lado, es parte de productos, porque lo que compras, es eso.

        O sea, lo que hacemos es, en index, decir que la ruta x ej /admin va a usar información del archivo de ruteo de admin, por otro lado en las rutas, 
        pongo el codigo de los diferentes metodos en el controlador de productos, y aca solo utilizo el controlador
    
    95 - Finishing the Controllers
    
        El use de la pagina de error, lo deja en el index del server, importa el controlador error que creó, mete su logica intermediaria ahí y usa eso.
        
    96 - Adding a Product Model
    
        Basicamente una o varias clases que representen a los tipos de objetos con los que vamos a estar trabajando y con sus difentes metodos.
        
        Propiedades
            del objeto

        Metodos:
            save
            get(id)
            getAll
            delete
            static fetchAll() // Lo pone estatico porque sino se tendría que crear un objeto solo para obtener algo que debería estar cargado si necesidad justamente de crear un objeto nuveo

        Después en los respectivos contorladores llamamos a nuestro modelo y lo utilizamos segun correspnda.

    97 - Storing Data in Files Via the Model
    
        Agrega una carpeta de data, para mostrar esto.
        En el modelo en la parte de guardar, genera el codigo para escribir el archivo. 
            Ver ejemplo en carpeta 97

        fs.readFile(archivo, (error, contenidoDeArchivo) =>{
            
        })

        JSON.parse // parsea el objeto en un Array
        JSON.stringify // convierte el array enjso
            
    98 - Fetching Data from Files Via the Model
    
        Como la función es estatica y se ejecuta ni bien se inicia, porque eso pasa con las clases estaticas, no es necesario llamarlas porque ya estan cargadas.
        el codigo se ejecuta asincronico (fs.readFile) que no lee el archivo de manera inmediata sino que registra el callback y termina la función, por eso se devuelve un array vacio.

        Para solucionar esto:
            Por el momento se le agrega un argumento a la función, un callback, entonces esto se va a llamar cuando readFile termine y se cierre la ejecución de fetchAll
            
            static fetchAll(cb){

                Se modifica el return []; por cb([]);
            }

            Idem por si no hay un error, parseamos el contenido del array en el json. y lo devolvemos.
            Por ultimo se modifica el getProductos, para renderizar en la parte del callback
                Ver ejemplo en carpeta 98 

    99 - Refactoring the File Storage Code
    
        Modifica codigo repetivo en una función helper que obtiene el archivo y reemplaza eso donde se estaba reptiendo el codigo.
    
    100 - Wrap Up

        Resumen
    
    101 - Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        More on MVC: https://developer.mozilla.org/en-US/docs/Glossary/MVC

        Recursos de esta clase
        00-starting-setup.zip
        01-finished-the-controller.zip
        02-adding-a-product-model.zip
        Ver más (2)

------------------------------------------------------------------

# Sección 8 - Optional: Enhancing the App
    Module Introduction

        Practicar lo que se aprendió agregando info al proyecto, es opcional este modulo.
    
    Creating the Shop Structure
    Working on the Navigation
    Registering the Routes
    Storing Product Data
    Displaying Product Data
    Editing & Deleting Products
    Adding Another Item
    Useful Resources & Links

------------------------------------------------------------------

# Sección 9 - Dynamic Routes & Advanced Models - Sección 9
    113 - Module Introduction
    
        Aprender sobre 
            como pasar parametros a las rutas, 
            como usar parametros por querystrnig 
            mejorar los modelos

    114 - Preparations
    
            Como nos salteamos el modulo anterior, hay que usar su proyecto.
            Voy a backapear todo y poner lo que puso el.

    115 - Applied Changes
    
        What changed in the attached files?
        Basically, a mobile navigation (for smaller/ mobile screens) was added. Besides that, only minor things were fixed.
    
    116 - Adding the Product ID to the Path

        Agregó al detalle del producto en la vista, el id para cuando hiciera click 
            /product/<%= product.id %>

        Agrego al archivo que simula ser bd, el id para los que ya tendría
        Agregó al guardar por ahora un id random con math.
    
    117 - Extracting Dynamic Params
    
        Con los : se le dice a Express que no busque una ruta sino un parametro
        
            /product/:produtId
        
        * Siempre estas rutas deben ir como ultima opción.

    118 - Loading Product Detail Data

        Crear una función estatica findByPk(id,cb), que obtiene la info del archivo y busca el id en particular que se le pasa por parametro.
        recorriendo los productos.
            products.find(p => { pd.id == id });
    
    119 - Rendering the Product Detail View
    
        Genera la vista detalle de producto y usa las diferentes propiedades del objecto para mostrar la info
        en el controlador renderiza la visa y pasa el producto.
    
    120 - Passing Data with POST Requests 

        En el html tiene que estar el atributo name, porque sino no se reconoce como parametro
        Si queres usar un include y justo esta dentro de un for y utiliza una propiedad del for, hay que pasarselo como segundo parametro.
        <%- include('.../includes/add-to-cart.ejs', {product: product}) %>

    121 - Adding a Cart Model

        Crea el modelo Cart, no crea instancias nuevas, porque carrito hay solo 1.
        Ver ese video otra vez.

    122 - Using Query Params
    
        Pasar parametros por queryString y recuperarlos.

    123 - Pre-Populating the Edit Product Page with Data
    
        Obtener un producto especifico por get para editarlo
    
    124 - Linking to the Edit Page
    
        llamar a la pagina de edición con el parametro por querystring del id del producto y editar en true

    125 - Editing the Product Data
    
        ruta para poder editarlo, modificaciones para poder obtener ese producto en particular y luego pisarlo con las modificaciones que se le hicieron

    126 - Adding the Product-Delete Functionality
    
        Generación del metodo eliminaren el modelo
    
    127 - Deleting Cart Items
    
        Agrega a la clase de cart un metodo para eliminar el producto del carrito

    127 - Displaying Cart Items on the Cart Page

        Genera una nueva vista para la parte de Cart, donde se van agregando los productos al carrito
    
    128 - Deleting Cart Items
    
        agrega el boton para eliminar, el html con el onlick para que vaya a la ruta correspondiente de eliminar, hacemos la ruta para eso tambien.
        elimina el producto x el id.

    130 - Fixing a Delete Product Bug
    
        arregla un bug quehabía

    131 - Wrap Up
    
        Resumen

    132 - Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Official Routing Docs: https://expressjs.com/en/guide/routing.html

        Recursos de esta clase
        00-starting-setup.zip
        01-extracting-dynamic-params.zip
        02-loading-product-detail-data.zip
        Ver más (7)
------------------------------------------------------------------

# Sección 10 - SQL Introduction
    
    133 - Module Introduction
         
         Aprender sobre: 
            Base de datos, que te ayudan a guardar y obtener datos.
            Sobre las distintas bd, SQL y NoSQL.
            Que tipo de base de dato es mejor para tu aplicación..

    134 - Choosing a Database

        Diferencias entre SQL y NoSQL
            Tener en cuenta siempre nuestra meta: guardar datos y que sean facilmente accesibles.
            Una bd es mas facil y rapida que usar un archivo, ya que a medida que crece un archivo ocuparia mas espacio en memoria.
                - Aparte no tenemos que leer todo el archivo para encontrar un pedazo de información.

            Tipos:
                SQL, ej:
                    - MySQL.

                NoSQL, ej:
                    - MongoDB

            SQL Database:
                - Pensar en "tablas"
                    - Tenemos campos/columnas con diferentes información que necesitamos.
                    - Cada fila (row), es un registro de información especifico.
                    Ej una tabla de usuarios, cada usuario es un registro.
                    - Cada tabla la podemos relacionar con otra trabla, ej productos con ordenes.

            Core SQL Database Caracteristicas:
                - Esquema de datos:
                    Un esquema bien definido sobre que información queremos de los datos en su tabla correspondiente y sus diferentes tipos.

                - Relaciones.
                    Relaciones entre tablas con tipos diferentes de relación:
                        - Uno a uno.
                        - Uno a muchos.
                        - Muchos a muchos.

            SQL: Structure query languaje. (Lenguaje de consulta estructurado).
                - Las consultas (queries) son comandos que usamos par interactuar con la base de datos, x ej: SELECT * FROM users WHERE age > 28
                - Tiene sintaxis especifica con (select, from, where, etc) con diferentes parametros (*, nombre de tabla, nombre de columna, num a buscar, etc)
                - 

    135 - NoSQL Introduction

         NoSQL (simplemente significa eso, no es un lenguaje estructurado de consultas), no se enfoca en esquemas.

         Seguimos teniendo una base de datos, por ej Shop:
            - Acá no tenemos tablas, sino COLECCIONES.
            - No buscamos records (registros), sino, DOCUMENTOS.
                Estos documentos son muy parecidos a la manera en la que describimos objetos en JS.
            - No tiene un esquema estricto.
                x ej: tenemos 2 documentos en nuestra colección, que uno tiene solamente nombre y el otro nombre y edad.
            - No tenemos relaciones reales, a cambio, estamos duplicando información. Por ej:
                Tenemos los datos del usuario que a su vez en la colección de ordenes, es un documento separado con mas detalles y no están conectados por ningún dato. Simplemente duplicamos la información.
                El tema es que si necesitamos actualizar la información, al tenemos que ACTUALIZAR EN MULTIPLES LUGARES, si realmente lo necesitan todos, aunque no tenemos que andar haciendo joins y demases, que pueden impactar en la performances.
            - Es muy rapida y eficas.
        
        No SQL, Caracteristicas:
            - No tenemos un esquema estricto, podemos mezclar datos en la misma colección.
            - No tenemos relaciones. Podemos relacionar datos de alguna manera, lo vamos a ver mas adelante. Generalmente vamos a tener NINGUNA o UNAS POCAS conecciones.

    136 - Comparing SQL and NoSQL

        Escalamiento vertical vs horizontal:

        Horizontal (SQL):
            Agregamos mas servidores.
            Mergeamos los datos en una bd.
            Es muy dificil y a veces imposible escalar, por la manera en que funciona sql, si bien podes agregar mas servidores, y compartir la info de todos en uno pero es muy dificil.

        Vertical (NoSQL):
            A un único servidor se le agrega mas cpu, memoria, etc. Con cloud es re facil hacer esto.
            Es facil de escalar.
         
        Elegir siempre del tipo de información que estamos guardando y si realmente es necesario que tenga relaciones.  

    137 - Setting Up MySQL

        https://dev.mysql.com/downloads/file/?id=488054
        Instalar eligiendo solo MySQL Server y MySQL Workbench
        Elegir legacy password: mysqlGia09 en la del trabajo, en mi pc es $gia.69$
        Chequear para que arranque una vez que se termine de instalar.
        Clic en la instancia local > 
            poner el pass -> 
                crear un nuevo squema > "node-complete", dejar los checks como estan.

    138 - Connecting our App to the SQL Database
        
        1) npm install --save mysql2
        2) Crear un archivo dentro de la carpeta utils: database.js
            Importar el paquete mysql2.
            Como conectarnos a la base de datos.  
            - Definimos crear un pool para que se manejen todas las queries, ya que no queremos una conección sola sino un pool de conexiones.
            - Definimos:
                - host (como va a correr por ahora en nuestra pc es localhost)
                - user (por default es root)
                - database ("no-complete")
                - password: la que se uso en la instalación

            const pool = mysql.createPool({
                host: 'localhost',
                user: 'root',
                database: 'node-complete',
                password: 'password'    
            });

            module.exports = pool.promise(); // Trabajar con promesas, nos va a permitir  manejar tasks, ya que es asincronico, en vez de cb.

            app.js
                importamos el archivo en una constante y de esta manera nos va a ayudar a manejar el pool de conecciones:

                const db = require('./util/database');

                db.execute('SELECT * FROM products');

            MySQL:
                Creamos la tabla productos.

    139 - Basic SQL & Creating a Table

        Creamos las columnas con su tipo. > apply
        Creamos un registro dummy > apply
        db.execute('SELECT * FROM products').then().catch();

    140 - Retrieving Data

        .then y .catch son funciones que encadenamos al resultado de nuestra llamada a la base.

        Promesa nos habilita a escribir codigo mas estructurado, en vez de tener una cb function como segundo argumento, simplemente tenemos:
        - then que es una función anonima que se ejecuta después de la llamada.
        - catch, toma cualquier error que pase.

        db.execute('SELECT * FROM products')
        .then((result) => {
            console.log(result);
        })
        .catch(err => {
            console.log(err);
        });


    141 - Fetching Products
        Eliminamos todo lo relacionado al archivo en productos.
        importamos nuestro pool.
        en shop modificamos la cb por la promesa 

        Tarea: Arreglar products.

    142 - Fetching Products - Time to Practice  
        Muestra como arreglar products (como en shop index)

    143 - Inserting Data Into the Database
        en Save() de products.
        db.execute('INSERT INTO productos (title, price, imageUrl, description) VALUES (?,?,?,?)',
        [this.title, this.price, this.imageUrl, this.description]);

        los signos de ? son para evitar injección de sql.

        Esto retorna una promesa, así que ahora actualizamos el save en admin.

    144 - Fetching a Single Product with the "where" Condition
        Tener en cuenta que cuando se obtienen datos de la base se obtienen como array, entonces si queremos pasar un solo producto, tenemos que pasar product[0], sino se rompe la vista.

    145 - Wrap Up
       
        Explica que se puede terminar el proyecto pero se va a llenar de queries.
        En vez de llenar todo de queries, va a enseñar como usar sequelize.

    146 - Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resource:

        Learn more about MySQL/ SQL in General: https://www.w3schools.com/sql/

        Learn more about the Node MySQL Package: https://github.com/sidorares/node-mysql2

        Recursos de esta clase
        00-starting-setup.zip
        01-connecting-our-app.zip
        02-fetching-products-time-to-practice.zip
        03-inserting-data.zip
        04-fetching-a-single-product.zip
------------------------------------------------------------------

# Sección 11 - Understanding Sequelize
    
    147 - Module Introduction
        bla bla Sequelize

    148 - What is Sequelize?

        Es un paquete de terceros, un mapper de data. (third party package) ORM
        Object
        Relational
        Mapping 
        Library

        Todo el SQL Code, lo mapea en JS objects detras de escena con metodos especificos que llamemos para ejecutar.

        En vez de escribir código escribimos js, como:

        const user = User.create({ name: 'Max', age: 32 })

        Nos ofrece:
            - Modelos -> User, Product
            - Instancias de estos modelos. -> const user = User.build()
            - Queries -> User.findAll()
            - Asociar, nuestros modelos -> User.hasMany(Product)

    149 - Connecting to the Database

        1) Instalar sequelize
            npm install --save sequelize // es una 
            dependencia de prod.

        2) Eliminamos la base de datos. (Porque ahora lo vamos a manejar con sequelize.)
        3) util.js:
            Creamos la conexión con la base de datos. 
            Eliminamos todo lo relacionado a mysql.
            // Se pone con mayus porque importa función de construcción.

            const Sequelize = require('sequelize');

            const sequelize = new Sequelize('node-complete','root','mysqlGia09', { 
                dialect: 'mysql', host: 'localhost'
            });

            module.export = sequelize;
            

            * host no es necesario ponerlo cuando es localhost, pero se puede poner igual.
        
    150 - Defining a Model
        
        Elimina todo lo que hay en models>produt
            importar sequelize
            importo mi db desde utils
            genero un modelo para Product, obtengo las configuraicones de sequelize y defino un modelo.

            const Sequelize = require('sequelize');

            const sequelize = new Sequelize('../util/database')

            const Product = sequelize.define('product', {
                id: {
                    type: Sequelize.INTEGER,
                    autoIncrement: true,
                    allowNulls: false,
                    primaryKey: true
                },
                title: Sequelize.STRING  // lo deja asi nomas solo porque e sun ejemplo.
                price: {
                    type: Sequelize.DOUBLE,
                    allowNulls: false
                },
                imageUrl: {
                    type: Sequelize.STRING,
                    allowNulls: false
                },
                description: {
                    type: Sequelize.STRING,
                    allowNulls: false
                }
            });

            module.exports = Products;

    151 - Syncing JS Definitions to the Database

        en app.js me ocupo de decirle a sequelize que mis modelos se conviertan en tablas o de obtener tablas  que pertenencen a otras al iniciar la app.

        Hace todo esto sin sobreescribirlas. 
        Mira todos los modelos que creamos, y crea las tablas en las bases y sus relaciones.

        sequelize.sync().then(result => {
            app.listen(3000);
            console.log(result);
        })
        .catch(err => {
            console.log(err);
        })
    
    152 - Inserting Data & Creating a Product
        admin.js

        exports.postAddProduct = (req, res, next) => {
        const title = req.body.title;
        const imageUrl = req.body.imageUrl;
        const price = req.body.price;
        const description = req.body.description;
            Product.create({
                title: title,
                price: price,
                imageUrl: imageUrl,
                description: description
            })
            .then(result => {
                console.log("CREATED PRODUCT");
                res.redirect('/admin/products');
            })
            .catch(err => {
                console.log(err);
            })
        };

    153 - MUST READ: findByPk() in Sequelize 5

        MUST READ: findByPk() in Sequelize 5
        One quick note:
            With Sequelize v5, findByPk() (which we'll use in this course) was replaced by findByPk().
            You use it in the same way, so you can simply replace all occurrences of findByPk() with findByPk()

    154 - Retrieving Data & Finding Products
        shop.js

        Product.findAll() // Se puede poner parametros ({ where: }), buscar mas en la docu.
        exports.getIndex = (req, res, next) => {
        Product.findAll()
            .then(products => {
                res.render('shop/index', {
                prods: products,
                pageTitle: 'Shop',
                path: '/'
                });
            })
            .catch(err =>{
                console.log(err);
            });
        };

        exports.getProducts = (req, res, next) => {
        Product.findAll()
            .then(products => {
            res.render('shop/product-list', {
                prods: products,
                pageTitle: 'All Products',
                path: '/products'
            });
            })
            .catch(err => console.log(err));
        };

    155 - Getting a Single Product with the "where" Condition

        Obtengo un solo producto, no un array, así que hay que cambiar findByPk and product
        1) manera:
            Product.findByPk(prodId)
            .then((product) => {
            res.render('shop/product-detail', {
                product: product,
                pageTitle: product.title,
                path: '/products'
            });
            })
            .catch(err => console.log(err));

        2) manera (where):
             Product.findAll({ where: {id: prodId}})
            const prodId = req.params.productId;
            .then((products) => {
                res.render('shop/product-detail', {
                    product: products[0],
                    pageTitle: products[0].title,
                    path: '/products'
                });
            })
            .catch(err => console.log(err));

    156 - Fetching Admin Products

        exports.getProducts = (req, res, next) => {
        Product.findAll()
            .then(products => {
                res.render('admin/products', {
                prods: products,
                pageTitle: 'Admin Products',
                path: '/admin/products'
                });
            })
        };

    157 - Updating Products

        exports.postEditProduct = (req, res, next) => {
            const prodId = req.body.productId;
            const updatedTitle = req.body.title;
            const updatedPrice = req.body.price;
            const updatedImageUrl = req.body.imageUrl;
            const updatedDesc = req.body.description;
            Product.findByPk(prodId)
                .then(product => {
                product.title = updatedTitle;
                product.price = updatedPrice;
                product.imageUrl = updatedImageUrl;
                product.description = updatedDesc;
                return product.save();
                })
                .then(result => {
                console.log('UPDATED PRODUCT');
                })
                .catch(err => { console.log(err) });
            res.redirect('/admin/products');
        };

    158 - Deleting Products

        exports.postDeleteProduct = (req, res, next) => {
            const prodId = req.body.productId;
            Product.findByPk(prodId)
            .then(product => {
                return product.destroy();
            })
            .then(result => {
                console.log("DESTROYED PRODUCT");
                res.redirect('/admin/products');
            })
            .catch(err => { console.log(err)});
        };
    159 - Creating a User Model

        const Sequelize = require('sequelize');
        const sequelize = require('../util/database');
        const User = sequelize.define('user', {
            id: {
                type: Sequelize.INTEGER,
                autoIncrement: true,
                allowNull: false,
                primaryKey: true
            },
            name: Sequelize.STRING,
            email: Sequelize.STRING
        });

        module.exports = User;

    160 - Adding a One-To-Many Relationship

        Product    <-*.1-    User
            *.* -> Cart  <- 1
            *.* -> Order <- 1

        app.js 
            const Product = require('./models/product');
            const User = require('./models/user');
            
            // Define las relaciones en la bd.
            Product.belongsTo(User, {constraints: true, onDelete: 'CASCADE' }); // 2 param es opcional
            User.hasMany(Product);

            // SOLO PARA DEV, NUNCA PROD!! Se elimina todo y se vuelve a crear para generar las relaciones de manera correcta.
            sequelize.sync({ force: true })

    161 - Creating & Managing a Dummy User
        
        // sequelize.sync({ force: true }), lo vuelve atras, una vez que hizo las relaciones.
       sequelize
        .sync()
        .then(result => {
            return User.findByPk(1)
        })
        .then(user => {
            if(!user){
                return User.create({name: 'Noelia', email: 'test@test.com' });
            }
            return user;
        })
        .then(user => {
            console.log(user);
            app.listen(3000);
        })
        .catch(err => {
            console.log(err);
        });

        //Creamos un middleare
        app.use((req,res,next) => {
            User.findByPk(1)
            .then(user => {
                req.user = user;
            })
            .catch(err => {console.log(err)});
        });
    
    162 - Using Magic Association Methods

    // podemos agregar el usuario acá:
        
        exports.postAddProduct = (req, res, next) => {
        const title = req.body.title;
        const imageUrl = req.body.imageUrl;
        const price = req.body.price;
        const description = req.body.description;
        Product.create({
            title: title,
            price: price,
            imageUrl: imageUrl,
            description: description
            userId: req.user.id
        })

    // Hay otra manera:
         req.user
            .createProduct({
                title: title,
                price: price,
                imageUrl: imageUrl,
                description: description
            })
            .then(result => {
                console.log("CREATED PRODUCT");
                res.redirect('/admin/products');
            })
            .catch(err => {
                console.log(err);
        }))

    163 - Fetching Related Products
        
        admin.js
            getEditPro..

              const prodId = req.params.productId;
                req.user
                    .getProducts({ where: { id: prodId } })
                    .then(products => {
                    const product = products[0];
                if (!product) {
                    return res.redirect('/');
                }


        exports.getProducts = (req, res, next) => {
        req.user
        .getProducts()
        .then(products => {

    164 - One-To-Many & Many-To-Many Relations

        deleteo todo lo de cart.
        models/cart.js
            const Sequelize = require('sequelize');

            const sequelize = require('../util/database');

            const Cart = sequelize.define('cart', {
            id: {
                type: Sequelize.INTEGER,
                autoIncrement: true,
                allowNull: false,
                primaryKey: true
            },
            quantity: Sequelize.INTEGER
            });

             module.exports = Cart;

        models/cart-item.js
            const Sequelize = require('sequelize');

            const sequelize = require('../util/database');

            const CartItem = sequelize.define('cartItem', {
            id: {
                type: Sequelize.INTEGER,
                autoIncrement: true,
                allowNull: false,
                primaryKey: true
            },
            quantity: Sequelize.INTEGER
            });

            module.exports = CartItem;

        app.js
        const Cart = require('./model/cart');
        const CartItem = require('./model/cart-item');

        Cart.belongsTo(User);
        Cart.belongsTo(Product, { throgh: CartItem });
        Product.belongsToMany(Cart, { throgh: CartItem });

        // Temporariamente volvemos a poner, para recrear las relaciones, SOLO DEV!
        .sync({ force: true }) 

    165 - Creating & Fetching a Cart

        exports.getCart = (req, res, next) => {
        req.user.getCart()
        .then(cart => {
        return cart.getProducts()
        .then(products => {
            res.render('shop/cart', {
            path: '/cart',
            pageTitle: 'Your Cart',
            products: products
            });
        })
        })
        .catch(err => {console.log(err)});
        // Cart.getCart(cart => {
        //   Product.fetchAll(products => {
        //     const cartProducts = [];
        //     for (product of products) {
        //       const cartProductData = cart.products.find(
        //         prod => prod.id === product.id
        //       );
        //       if (cartProductData) {
        //         cartProducts.push({ productData: product, qty: cartProductData.qty });
        //       }
        //     }
        //     res.render('shop/cart', {
        //       path: '/cart',
        //       pageTitle: 'Your Cart',
        //       products: cartProducts
        //     });
        //   });
        // });
        };

    166 - Adding New Products to the Cart
        
            exports.postCart = (req, res, next) => {
            const prodId = req.body.productId;
            let fetchedCart;
            req.user.getCart()
            .then(cart => {
                fetchedCart = cart;
                return cart.getProducts({where: { id: prodId }});
            })
            .then(products => {
                let product;
                if(products.length > 0){
                product = products[0];
                }
                let newQuantity = 1;
                if(product){
                
                }

                return Product.findByPk(prodId)
                .then(product => {
                return fetchedCart.addProduct(product, {
                    through: { quantity: newQuantity}
                });
                })
                .catch(err => {console.log(err)});
            })
            .then(() => {
                res.redirect('/cart');
            })
            .catch(err => { console.log(err)});
            };

    167 - Adding Existing Products & Retrieving Cart Items

        views/shop.ejs
             <h1><%= p.title %></h1>
                            <h2>Quantity: <%= p.cartItem.quantity %></h2>
                            <form action="/cart-delete-item" method="POST">
                                <input type="hidden" value="<%= p.id %>" name="productId">
                                <button class="btn danger" type="submit">Delete</button>
                            </form>


        exports.postCart = (req, res, next) => {
        const prodId = req.body.productId;
        let fetchedCart;
        let newQuantity = 1;

        req.user.getCart()
        .then(cart => {
            fetchedCart = cart;
            return cart.getProducts({where: { id: prodId }});
        })
        .then(products => {
            let product;
            if(products.length > 0){
            product = products[0];
            }
            
            if(product){
            const oldQuantity = product.cartItem.quantity;
            newQuantity = oldQuantity + 1;
            return product;
            }
            return Product.findByPk(prodId)
        })
        .then(product => {
            return fetchedCart.addProduct(product, {
            through: { quantity: newQuantity }
            });
        })
        .then(() => {
            res.redirect('/cart');
        })
        .catch(err => { console.log(err)});
        };


    168 - Deleting Related Items & Deleting Cart Products

        exports.postCartDeleteProduct = (req, res, next) => {
        const prodId = req.body.productId;
        req.user.getCart()
        .then(cart => {
            return cart.getProducts({ where: { id: prodId }});
        })
        .then(products => {
            const product = products[0];
            return product.cartItem.destroy();
        })
        .then(result => {
            res.redirect('/cart');
        })
        .catch(err => { console.log(err)});
        };

    169 - Adding an Order Model

        crea en models: Order (copiando y pegando cart-item)
        crea order-item, mismo paso.

        app.js
            const Order = require('./models/order');
            const OrderItem = require('./models/order-item');

            Order.belongsTo(User);
            User.hasMany(Order);
            Order.belongsToMany(Product,  { through: OrderItem });    
            
    170 - Storing Cartitems as Orderitems
            views/shop/cart.ejs

            </ul>
            <hr>
            <div class="centered">
                <form action="/create-order" method="POST">
                    <button type="submit" class="btn">Order Now!</button>
                </form>
            </div>

            controllers/shop.js
               exports.postOrder = (req, res, next) => {
                req.user.getCart()
                .then(cart => {
                    return cart.getProducts();
                })
                .then(products => {
                    req.user.createOrder()
                    .then(order =>  {
                    return order.addProduct(products.map(product => {
                        product.orderItem = { quantity: product.cartItem.quantity };
                        return product;
                    }));

                    })
                    .catch(err => { console.log(err); });
                })
                .then(result => {
                    res.redirect('/orders');
                })
                .catch(err => { console.log(err); });
                };

            routes/shop.js
                router.post('/create-order', shopController.postOrder);


    171 - Resetting the Cart & Fetching and Outputting Orders

        exports.postOrder = (req, res, next) => {
        let fetchedCart;
        req.user.getCart()
        .then(cart => {
            fetchedCart = cart;
            return cart.getProducts();
        })
        .then(products => {
            req.user.createOrder()
            .then(order =>  {
            return order.addProduct(products.map(product => {
                product.orderItem = { quantity: product.cartItem.quantity };
                return product;
            }));

            })
            .catch(err => { console.log(err); });
        })
        .then(result => {
            fetchedCart.setProducts(null);
        })
        .then(result => {
            res.redirect('/orders');
        })
        .catch(err => { console.log(err); });
        };

        controllers.shop.js
            exports.getOrders = (req, res, next) => {
            req.user.getOrders()
            .then(orders => {
                res.render('shop/orders', {
                path: '/orders',
                pageTitle: 'Your Orders'
                });
            })
            .catch(err => { console.log(err)});
            };

        views/shop/order.ejs
            <%- include('../includes/head.ejs') %>
            </head>

            <body>
                <%- include('../includes/navigation.ejs') %>
                <main>
                    <% if (orders.length <= 0) { %>
                        <h1>Nothing there!</h1>
                    <% } else { %>
                        <ul>
                            <% orders.forEach(order => { %>
                                <li>
                                    <h1># <% orders.id %> </h1>
                                    <ul>
                                        <% order.orderItem.forEach(item => { %>
                                            <li><%= item.title %> (<%= item.quantity %>)  </li>
                                        <% }); %>
                                    </ul>
                                </li>
                            <% }) %>
                        </ul>
                    <% } %>
                </main>
                <%- include('../includes/end.ejs') %>
            
            controllers/shop.js
                exports.getOrders = (req, res, next) => {
                req.user.getOrders({ include: ['products']})

            view/shop
                <%- include('../includes/head.ejs') %>
                </head>

                <body>
                    <%- include('../includes/navigation.ejs') %>
                    <main>
                        <% if (orders.length <= 0) { %>
                            <h1>Nothing there!</h1>
                        <% } else { %>
                            <ul>
                                <% orders.forEach(order => { %>
                                    <li>
                                        <h1># <% order.id %> </h1>
                                        <ul>
                                            <% order.products.forEach(product => { %>
                                                <li><%= product.title %> (<%= product.orderItem.quantity %>)  </li>
                                            <% }) %>
                                        </ul>
                                    </li>
                                <% }) %>
                            </ul>
                        <% } %>
                    </main>
                    <%- include('../includes/end.ejs') %>

            exports.getOrders = (req, res, next) => {
            req.user
            .getOrders({ include: ['products']})
            .then(orders => {
                res.render('shop/orders', {
                path: '/orders',
                pageTitle: 'Your Orders',
                orders: orders
                });
            })
            .catch(err => { console.log(err)});
            };

    172 - Wrap Up
        Todo lo que vimos sobre sql y sequelize, comparación.

    173 - Useful Resources & Links
        Useful Resources & Links
        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resource:

        Sequelize Official Docs: http://docs.sequelizejs.com/

        Recursos de esta clase
        01-defining-a-model.zip
        02-inserting-data-and-creating-a-product.zip
        03-getting-a-single-product.zip
        04-updating-products.zip
        05-deleting-products.zip
        06-adding-a-one-to-many-relationship.zip
        07-creating-and-managing-a-user.zip
        08-fetching-related-products.zip
        09-creating-and-fetching-a-cart.zip
        10-adding-existing-products-and-retrieving.zip
        11-deleting-related-items.zip
        12-storing-cartitems-as-orderitems.zip
        13-resetting-the-cart-and-fetching.zip
        
------------------------------------------------------------------

# Sección 12 - Working with NoSQL & Using MongoDB

    174 - Module Introduction
        bla bla NoSQL Databases / MongoDB.

    175 - What is MongoDB?
        Es una introducción esto, si queres aprender mas, el tiene un curso exclusivo de mongodb.

        Mongo viene de "enorme", por humongous.
        Esta creado para crear aplicaciones de alta escala, donde se necesita buscar información de manera rapida,mismo al guardarla, actualizarla, etc.

        Puede tener multiple base de datos, que a su vez tiene colecciones, que a su vez tiene, documentos.

        No es necesario tener el mismo esquema en todos los documentos.

        MongoDB usa JSON, para guardar info en las collections. (bson -binary json-, transforma por atras antes de guardarlo en archivos)

        Los documentos adentro de documentos son documentos "embebidos".

    176 - Relations in NoSQL
        Para que funcione de manera rapida no es que existen relaciones y si tengo que buscar las ordenes del usuario, después tengo que buscar la información del usuario.

        Acá tendríamos dentro de la colección Orders, datos del usuario embebido, por ende nos ahorramos una llamada por ende, es mucho mas rapido.

        Tipos de relaciones:
            - Nested/Embedded documentos
                Un documento metido en otro.
            - Referencias
                mediante el id de los documentos.

    177 - Setting Up MongoDB
        
        Usamos Atlas, que es mongo en la nube. Si bien se puede bajar e instalar local, el usa esto en el curso.

        Si bien lo ideal es elegir un cluster cerca de tu localización, hay que elegir uno que sea gratis. 

        Te hace elegir por "default":
            - N. Virginia
            - Cluster tier: MO (el gratis)
            - Dejar todo como esta. (amazon, etc)
        
        Crear un usuario - Security > Database Access:
            User: admin_mongo
            Pass autogenerada: ywGX4vucwQksRGIb

        Agregar mi ip a la whitelist:
            186.139.114.102
        
        Elegir connect:
            Elegir connect with your application
            Elegir el driver de mongo db que vamos a instalar para poder conectarnos localmente.
            
    178 - Installing the MongoDB Driver

        Instalar el driver: 
            npm install --save mongodb
        
        Borra todo lo relacionado a mysql en app.js

        util.js
            const mongodb = require('mongodb');
            const MongoClient = mongodb.MongoClient;

            const mongoConnect = (cb) => {
                MongoClient.connect('mongodb+srv://admin_mongo:ywGX4vucwQksRGIb@cursomax-xoskd.mongodb.net/test?retryWrites=true&w=majority')
                .then(client => {
                    console.log("Conectado");
                    callback(client)
                })
                .catch(err => {console.log(err)});
            }
            
            module.export = mongoConnect;

            app.js 
                const mongoConnect = require('./util/database')
            
                // Abajo de todo:
                mongoConnect((client) =>{
                    app.listen(3000);
                    console.log(client);
                })

            *No olvidarse cambiar el password, revisar de tener bien el usuario que creamos.

            * Comenta las rutas en app.js momentaneamente porque todavía apuntan a mysql.

    179 - Creating the Database Connection
            Agrega otra vez, para probar tdo lo de admin, cambia en models, lo de producto (mysql) por mongodb.

            const mongoConnect = require('../util/database');

            class Product {
            constructor(title, price, description, imageUrl) {
                this.title = title;
                this.price = price;
                this.description = description;
                this.imageUrl = imageUrl;
            }

            save() {
            }
            }

            const Product = sequelize.define('product', {
            id: {
                type: Sequelize.INTEGER,
                autoIncrement: true,
                allowNull: false,
                primaryKey: true
            },
            title: Sequelize.STRING,
            price: {
                type: Sequelize.DOUBLE,
                allowNull: false
            },
            imageUrl: {
                type: Sequelize.STRING,
                allowNull: false
            },
            description: {
                type: Sequelize.STRING,
                allowNull: false
            }
            });

            module.exports = Product;

    180 - Finishing the Database Connection
        Para conectarse a una base de datos especifica, en el connection string solamente hay que ponerle la base que necesitamos.

        database.js
            const mongodb = require("mongodb");
            const MongoClient = mongodb.MongoClient;

            let _db;

            const mongoConnect = (callback) => {
            MongoClient.connect(
                "mongodb+srv://admin_mongo:ywGX4vucwQksRGIb@cursomax-xoskd.mongodb.net/test?retryWrites=true&w=majority"
            )
                .then(client => {
                console.log("Conectado");
                _db = client.db();
                callback();
                })
                .catch(err => {
                console.log(err);
                throw err;
                });
            };

            const getDb = () => {
            if(_db){
                return _db;
            }
            
            throw "No database found";
            };

            module.exports = mongoConnect;
            module.getDb = getDb;


            * Es un patron que se utiliza, para que mongodb se maneje de manera eficiente con pooling, al igual que mysql/sql.

            product.js
                //cambia solo eso.
                const getDb = require('../util/database').getDb;

    181 - Using the Database Connection
        Si bien podemos ver la docu en la página...

        products.js
          const getDb = require('../util/database').getDb;

            class Product {
            constructor(title, price, description, imageUrl) {
                this.title = title;
                this.price = price;
                this.description = description;
                this.imageUrl = imageUrl;
            }

            save() {
                const db = getDb();
                db.collection('products')
                .insertOne(this)
                .then(result => {
                console.log(result);
                })
                .catch(err => {
                console.log(err);
                })
            }
            }

            module.exports = Product;
            
    182 - Creating Products

        Empieza a actualizar los modelos con lo de mongodb.

        admin.js
             const product = new Product(title, price, description, imageUrl);
            product
            .save()
            .then(result => {

        models.product.js
            // agrega el return a db 

            save() {
            const db = getDb();
            return db
            .collection('products')

    183 - Understanding the MongoDB Compass
    184 - Fetching All Products
    185 - Fetching a Single Product
    186 - Making the "Edit" & "Delete" Buttons Work Again
    187 - Working on the Product Model to Edit our Product
    188 - Finishing the "Update Product" Code
    189 - One Note About Updating Products
    190 - Deleting Products
    191 - Fixing the "Add Product" Functionality
    192 - Creating New Users
    193 - Storing the User in our Database
    194 - Working on Cart Items & Orders
    195 - Adding the "Add to Cart" Functionality
    196 - Storing Multiple Products in the Cart
    197 - Displaying the Cart Items
    198 - Fixing a Bug
    199 - Deleting Cart Items
    200 - Adding an Order
    201 - Adding Relational Order Data
    202 - Getting Orders
    203 - Removing Deleted Items From the Cart
    204 - Wrap Up
        Resumen de todo..
    205 - Useful Resources & Links
        Useful Resources & Links
        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resource:

        MongoDB Official Docs: https://docs.mongodb.com/manual/core/security-encryption-at-rest/https://docs.mongodb.com/manual/

        SQL vs NoSQL: https://academind.com/learn/web-dev/sql-vs-nosql/

        Learn more about MongoDB: https://academind.com/learn/mongodb

        Recursos de esta clase
        00-starting-setup.zip
        01-using-the-database-connection.zip
        02-fetching-all-products.zip
        03-fetch-a-single-product.zip
        04-finishing-the-update-product-code.zip
        05-deleting-products.zip
        06-fixing-the-add-product-functionality.zip
        07-storing-the-user-in-the-database.zip
        08-added-the-add-to-cart-functionality.zip
        09-displaying-the-cart-items.zip
        10-deleting-cart-items.zip
        11-adding-relational-order-data.zip
        12-removing-deleted-items-from-the-cart.zip

    206 - Two Adjustments (behind the scenes)
        Behind the scenes, two files were deleted:
        order-item.js
        order.js
        Why? We simply don't need them anymore, the way we now structured our models.

------------------------------------------------------------------

# Sección 13 - Working with Mongoose

    Module Introduction
    What is Mongoose?
    Connecting to the MongoDB Server with Mongoose
    Creating the Product Schema
    Saving Data Through Mongoose
    Fetching All Products
    Fetching a Single Product
    Updating Products
    Deleting Products
    Adding and Using a User Model
    Using Relations in Mongoose
    One Important Thing About Fetching Relations
    Working on the Shopping Cart
    Loading the Cart
    Deleting Cart Items
    Creating & Getting Orders
    Storing All Order Related Data
    Clearing the Cart After Storing an Order
    Getting & Displaying the Orders
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Sección 14 - Sessions & Cookies

    228 - Module Introduction
        bla bla, cookies..

    229 - What is a Cookie?
        
        Por ejemplo, cuando el usuario se quiere loguear, guardamos cierta información del login, para que la proxima vez que haga un request, nosotros tengamos la información de que el usuario esta autenticado.

        Para eso, desde node, podemos enviar una cookie por header.

        Las cookies se guardan del lado del cliente.

    230 - The Current Project Status

        // A el, el proyecto le con Mongoose, dice que hay que bajar las cosas pero quiero fucking avanzar.

    231 - Optional: Creating the Login Form
        
        - en routes, genera auth.js
        - importa en app.js el modulo.
        - genera el controlador auth.js

    232 - Adding the Request Driven Login Solution
    233 - Setting a Cookie
    234 - Manipulating Cookies
    235 - Configuring Cookies
    236 - What is a Session?
    237 - Initializing the Session Middleware
    238 - Using the Session Middleware
    239 - Using MongoDB to Store Sessions
    240 - Sessions & Cookies - A Short Summary
    241 - Time to Practice - Sessions and Cookies 
    242 - 1 pregunta
    243 - Deleting a Cookie
    244 - Fixing Some Minor Bugs
    245 - Making "Add to Cart" Work Again
    246 - Two Tiny Improvements
    247 - Wrap Up
    248 - Code Adjustments
    249 - Useful Resources & Links

------------------------------------------------------------------

# Sección 15 - Adding Authentication

    Module Introduction
    What is Authentication?
    How is Authentication Implemented?
    Our Updated Project Status
    Implementing an Authentication Flow
    Encrypting Passwords
    Adding a Tiny Code Improvement
    Adding the Signin Functionality
    Working on Route Protection
    Using Middleware to Protect Routes
    Understanding CSRF Attacks
    Using a CSRF Token
    Adding CSRF Protection
    Fixing the Order Button
    Providing User Feedback
    Optional: Styling Error Messages
    Finishing the Flash Messages
    Adding Additional Flash Messages
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Sección 16 - Sending Emails

    268 - Module Introduction
    269 - How Does Sending Emails Work?
        
        Hacer un servidor que envie mails desde 0 es dificil.
        Recibir y enviar request es totalmente difernte a recibir y enviar mails, por lo que se va a utilziar un pquete de terceros.

    270 - Using SendGrid

        Es gratis los primeros 30 días y te deja enviar hasta 40.000 mails, después de eso podes mandar 100 por día gratis, por siempre.

        Hay que crear una cuenta.
        npm install --save nodemailer nodemailer-sendgrid-transport

    271 - Using Nodemailer to Send an Email
        
        Hay que agregar las importaciones necesarias
        nodemailer y nodemailer-sendgrid-transport

        configurar el transporter, apikey, apiuser, se obtiene en la pagina de sendgrid.

        transporter.sendMail({
            to: email,
            from: 'shop@node-complete.com',
            subjects: 'Signup succeded!',
            html: '<h1>Te logueaste correctamente</h1<'
        })
        .catch(err => {console.log(err)});

    272 - Potential Limitation for Large Scale Apps
        Re-veer en caso de ser necesario.
    273 - Useful Resources & Links
        Useful Resources & Links
        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Nodemailer Official Docs: https://nodemailer.com/about/

        SendGrid Official Docs: https://sendgrid.com/docs/

        Recursos de esta clase
        01-using-nodemailer-to-send-emails.zip
------------------------------------------------------------------

# Sección 17 - Advanced Authentication

    274 - Module Introduction
        Resetear passwords, authorization.
    275 - Resetting Passwords
    276 - Implementing the Token Logic
    277 - Creating the Token
    278 - Creating the Reset Password Form
    279 - Adding Logic to Update the Password
    280 - Why we Need Authorization
    281 - 280 - Adding Authorization
    282 - Adding Protection to Post Actions
    283 - Why Editing Fails
    284 - Wrap Up
    285 - Useful Resources & Links

------------------------------------------------------------------

# Understanding Validation

    Module Introduction
    Why Should We Use Validation?
    How to Validate Input?
    Setup & Basic Validation
    Using Validation Error Messages
    Built-In & Custom Validators
    More Validators
    Checking For Field Equality
    Adding Async Validation
    Time to Practice - Validation 
    1 pregunta
    Keeping User Input
    Adding Conditional CSS Classes
    Adding Validation to Login
    Sanitizing Data
    Validating Product Addition
    Validating Product Editing
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Error Handling

    Module Introduction
    Types of Errors & Error Handling
    Analyzing the Error Handling in the Current Project
    Errors - Some Theory
    Throwing Errors in Code
    Returning Error Pages
    Using the Express.js Error Handling Middleware
    Updating the App
    Using the Error Handling Middleware Correctly
    Status Codes
    Available Status Codes
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# File Upload & Download

    Module Introduction
    Adding a File Picker to the Frontend
    Handling Multipart Form Data
    Handling File Uploads with Multer
    Configuring Multer to Adjust Filename & Filepath
    Filtering Files by Mimetype
    Storing File Data in the Database
    Remove imageUrl from "Add Product"
    Serving Images Statically
    Downloading Files with Authentication
    Setting File Type Headers
    Restricting File Access
    Streaming Data vs Preloading Data
    Using PDFKit for .pdf Generation
    Generating .pdf Files with Order Data
    Deleting Files
    Fixing Invoice Links
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Adding Pagination

    Module Introduction
    Adding Pagination Links
    Retrieving a Chunk of Data
    Skip & Limit with SQL
    Preparing Pagination Data on the Server
    Adding Dynamic Pagination Buttons
    Re-Using the Pagination Logic & Controls
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Understanding Async Requests

    344 - Module Introduction
    345 - What are Async Requests?

    Cliente ->  Request (Data (JSON))              ->  Server
            <-  Response(html page) (Data(JSON))   <-
        
    346 - Adding Client Side JS Code

        public/js/admin.js
            // Código que corre en el cliente.
            const deleteProduct = (btn) => {
                const productId = btn.parentNode.querySelector('name=productId').value;
                const cstk = btn.parentNode.querySelector('name=_cstk').value;
            };

        views/admin/products.ejs
            <script src="/js/admin.js"></script>
            Cambia el submit por un type button, también le agrega:
            onClick="deteleProduct(this)"

    347 - The JSON Data Format
        What is JSON?

        JSON stands for JavaScript Object Notation and a typically JSON data structure looks like this:

        {
            "name": "Your Name",
            "age": 29,
            "courses": [
                "angular-the-complete-guide",
                "react-the-complete-guide"
            ],
            "profile": {
                "joined": "2017-05-21",
                "courses": 2
            },
            "averageRating": 4.8,
            "active": true
        }
        It looks a lot like a normal JavaScript object, but one important difference is that all key names are enclosed by double quotation marks (").

        Besides that, you can store text (string), numeric (integers and floats) and boolean data as well as nested objects and arrays.

        You can dive deeper on this page: https://www.json.org/

    348 - Sending & Handling Background Requests

        routes/admin.js
            router.delete('/product/:productId', isAuth, adminController.deleteProduct);
            
        controller/admin.js
            modifica el nombre de la función.
            obtengo los valores del request:
                req.params.productId
                no redirigimos mas a /admin/products.
                res.status(200).json({message: 'Success' })
                en el catch retornamos 500 y json.
                res.status(500).json({message: 'Delete error' })
        
        public/js/admin.js
            // Código que corre en el cliente.
            const deleteProduct = (btn) => {
                const productId = btn.parentNode.querySelector('name=productId').value;
                const cstk = btn.parentNode.querySelector('name=_cstk').value;

                fetch('/admin/product/' + prodId, {
                    method: 'DELETE',
                    headers: {
                        'csrf-token': csrf
                    }
                })
                .then(result => {
                    console.log(result);
                })
                .catch(err => {
                    console.log(err)
                });
            };


    349 - Manipulating the DOM
    
        public/js/admin.js
            // Código que corre en el cliente.
            const deleteProduct = (btn) => {
                const productId = btn.parentNode.querySelector('name=productId').value;
                const cstk = btn.parentNode.querySelector('name=_cstk').value;

                const productElement = btn.closest('article');

                fetch('/admin/product/' + prodId, {
                    method: 'DELETE',
                    headers: {
                        'csrf-token': csrf
                    }
                })
                .then(result => {
                    console.log(result);
                })
                 .then(data => {
                    console.log(data);
                    productElement.parentNode.removeChild(productElement);
                })
                .catch(err => {
                    console.log(err)
                });
            };

    350 - Useful Resources & Links
        Useful Resources & Links
        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        More on the fetch API: https://developers.google.com/web/updates/2015/03/introduction-to-fetch

        More on AJAX Requests: https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX/Getting_Started

        Recursos de esta clase
        01-adding-client-side-code.zip
        02-manipulating-the-dom.zip
------------------------------------------------------------------

# Adding Payments

    351 - Module Introduction
        Bla bla, usar una api de un vendor que se llama Stripe.

    352 - How Payments Work
        Como funciona Stripe, basicamente le mandas los datos de la tarjeta, si valida ok, te generan un Token
        y eso después lo tenes que mandar al confirmar la compra.

    353 - Adding a Checkout Page
        Agrega una ruta de checkout, modelo, vista etc.

    354 - Using Stripe in Your App
        Crear una cuenta en Stripe.
        Copiar y pegar la información de la pagina (el formulario)
        * No lo termine de ver, nunca vamos a usar esto.

    355 - Useful Resources & Links
        Useful Resources & Links
        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Official Stripe.js Docs: https://stripe.com/docs

        Recursos de esta clase
        01-added-checkout-page.zip
        02-using-stripe.zip
------------------------------------------------------------------

# Working with REST APIs - The Basics
    
    Module Introduction
    What are REST APIs and why do we use Them?
    Accessing Data with REST APIs
    Understanding Routing & HTTP Methods
    REST APIs - The Core Principles
    Creating our REST API Project & Implementing the Route Setup
    Sending Requests & Responses and Working with Postman
    REST APIs, Clients & CORS Errors
    Sending POST Requests
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Working with REST APIs - The Practical Application

    Module Introduction
    REST APIs & The Rest Of The Course
    Understanding the Frontend Setup
    Planning the API
    Fetching Lists of Posts
    Adding a Create Post Endpoint
    Adding Server Side Validation
    Setting Up a Post Model
    Storing Posts in the Database
    Static Images & Error Handling
    Fetching a Single Post
    Image Names & Windows
    Uploading Images
    Updating Posts
    Deleting Posts
    Adding Pagination
    Adding a User Model
    Adding User Signup Validation
    Signing Users Up
    How Does Authentication Work?
    Starting with User Login
    Logging In & Creating JSON Web Tokens (JWTs)
    Using & Validating the Token
    Adding Auth Middleware to All Routes
    Connecting Posts & Users
    Adding Authorization Checks
    Clearing Post-User Relations
    Time to Practice - Working with REST APIs 
    1 pregunta
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Sección 26 - Understanding Async Await in Node.js

    396 - Module Introduction
    397 - What is Async Await All About?
        Son dos palabaras reservadas.
        
        Sirve para generar request de manera asincronica, o sea, que si estas haciendo algo podes ir a hacer otra cosa y e ir a donde estaba ese algo cuando se termine.
    
    398 - Transforming "Then Catch" to "Async Await"
        
        async: se pone adelante de la función que queremos que sea asincronica.
        await: Los await se utilizan para frenar la ejecución de los llamados en las que su respuesta es necesaria para el siguiente paso.

        Time to Practice - Async Await // NO LA HICE.
        
            Tarea: Time to Practice - Async Await
            13 minutos para finalizar146 soluciones del estudiante
            Asyncs Await should be clear shouldn't it? Time to test our newly gained knowledge!

    399 - The User Name is Missing!
            Maybe you noticed that on the frontend, the username is missing.

            We'll fix that in the next modules but you can also fix it right now of course.

            The reason for it missing is that I accidentally removed the populate('creator') step when fetching the post data in our controller action.

            Example:

            When fetching posts, this snippet:

            Post.find()
                .countDocuments()
                .then(count => {
                totalItems = count;
                return Post.find()
                    .skip((currentPage - 1) * perPage)
                    .limit(perPage);
                })
            should become

            Post.find()
                .countDocuments()
                .then(count => {
                totalItems = count;
                return Post.find()
                    .populate('creator')
                    .skip((currentPage - 1) * perPage)
                    .limit(perPage);
                })

    402 - Wrap Up
        
        Para Mongoose, si bien no retorna realmente promesas, se puede usar async await.
        Si es realmente necesario a las funcione al final se le debe agregar .exec();

    403 - Useful Resources & Links

        Useful Resources & Links
        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Async-await - More Details: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function

        Recursos de esta clase
        01-transforming-then-catch.zip
        assignment-backend-solution.zip
        assignment-frontend-solution.zip

------------------------------------------------------------------

# Sección 27 - Understanding Websockets & Socket.io

    402 - Module Introduction
        Porque usar realtime.
        Como agregar comunicacíón real a mi aplicación de Node.

    403 - What Are Websockets & Why Would You Use Them?
        
        Cliente -> 1 Request ->   Servidor
                <- 2 Response <-----

        WebSockets: (usa el protocolo http)
         
        Cliente -> 1 Send Data ->   Servidor
                <- 2 Push Data  <-----

    404 - Websocket Solutions - An Overview
        Socket.io

    405 - Setting Up Socket.io on the Server
        
        npm install --save socket.io

        const server = app.liten(3000);
        const io = require('socket.io')(server);
        // se ejecuta para cada cliente que se conecte.
        io.on('connection', socket => {
            console.log('Cliente conectado');
        });

    406 - Establishing a Connection From the Client
        
        npm install --save socket.io-client
        
        Es el código que corre en nuestro cliente.

        import openSocket from 'socket.io-client';
        openSocket('http://localhost:3000')

        * Ver bien esto porque lo esta haciendo sobre una aplicación react que no se de donde salió.
        
    407 - Identifying Realtime Potential
    408 - Sharing the IO Instance Across Files
    409 - Synchronizing POST Additions
    500 - Fixing a Bug - The Missing Username
    501 - Updating Posts On All Connected Clients
    502 - Sorting Correctly
    503 - Deleting Posts Across Clients
    504 - Wrap Up
    505 - Useful Resources & Links

------------------------------------------------------------------

# Working with GraphQL

    Module Introduction
    What is GraphQL?
    Understanding the Setup & Writing our First Query
    Defining a Mutation Schema
    Adding a Mutation Resolver & GraphiQL
    Adding Input Validation
    Handling Errors
    Connecting the Frontend to the GraphQL API
    Adding a Login Query & a Resolver
    Adding Login Functionality
    Adding a Create Post Mutation
    Extracting User Data From the Auth Token
    Sending the "Create Post" Query
    Fixing a Bug & Adding New Posts Correctly
    Adding a "Get Post" Query & Resolver
    Sending "Create Post" and "Get Post" Queries
    Adding Pagination
    Uploading Images
    Fetching the imageUrl
    Viewing a Single Post
    Updating Posts
    Deleting Posts
    Adding Posts & Pagination
    Managing the User Status
    Using Variables
    Fixing a Pagination Bug
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Deploying our App

    Module Introduction
    Deploying Different Kinds of Apps
    Deployment Preparations
    Using Environment Variables
    Using Production API Keys
    Setting Secure Response Headers with Helmet
    Compressing Assets
    Setting Up Request Logging
    More on Logging
    Setting Up a SSL Server
    Using a Hosting Provider
    Understanding the Project & the Git Setup
    A Deployment Example with Heroku
    Storing User-generated Files on Heroku
    Deploying APIs
    Useful Resources & Links

------------------------------------------------------------------

# Node.js as a Build Tool & Using npm

    477 - Module Introduction
        Que cosas se pueden hacer con node.

    478 - npm & Node.js
        Cuando instalamos Node, tenemos ambos.

        Node.js
            Ejecutar codigo.
            Interactuar con archivos.

        npm
            Manejar paquetes.
            Correr scripts.
            
    479 - Using npm
        Node Package Manager (npm)
        
        npm cli:
            sirve para correr diferentes comandos.
        
        Tenemos funcionalidad aislada,en el código de Node, ej: generar un numero random.
        Se puede compartir internamente o externamente, o sea, se genera un package o se sube a npm Repository (para que sea publico.)

        En la pagina oficial, podemos buscar packages, podemos ver todo tipo de información a cerca de cada package.

        Muestra toda la info que hay en la pagina oficial, todos los comandos que tiene npm, etc..

        npm install --help

    480 - Versioning in package.json
        Versioning in package.json
        When installing a package with npm install --save or --save-dev (or --save-prod, which replaces --save), you end up with entries in your package.json file, that look something like this:

        "express": "^4.16.3"
        What does the ^ mean?

        You can learn about all available version annotations/ syntaxes here: https://docs.npmjs.com/misc/semver#versions

        This post on Stackoverflow provides a great summary: https://stackoverflow.com/a/25861938

    481 - What is a Build Tool?
        
        scripts, packages que te sirven para optimizar el codigo para todos los navegadores como babel.
        
        npm run build x ej en una app react.
            Si te fijas el codigo que genera en la carpeta de build, es todo codigo minificado y optimizado apra todos los navegadores.
        
    482 - Using Node.js in Build Processes
        Mas info de lo mismo.
    483 - Useful Resources & Links
        Useful Resources & Links
        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Official npm Docs: https://docs.npmjs.com/

        Learn more about Webpack (a build tool using Node.js): https://academind.com/learn/webpack

------------------------------------------------------------------

# Roundup

    484 - Course Roundup
        Seguir codeando, probando cosas, apis, etc.
        Meterse aún mas en el desarrollo fronted.

    485 -Course Slides
        Attached you can find the course slides.

        Recursos de esta clase
        slides.pdf

    486 - Bonus: More Content!
        Bonus: More Content!
        I got a lot of other high-quality & bestselling courses you might be interested in: https://academind.com/learn/our-courses/

        I'd love to welcome you on board of any of these courses! :-)

        Also don't forget to subscribe to my newsletter on https://academind.com/ to receive the latest updates and exclusive offers!

        And in case you didn't know: On the same page as well as on my YouTube channel I got loads of additional tutorials.

        Last but not least - I tweet on @maxedapps and on @academind_real, would love to see you there!

-------------------- IDEAS BELGA ---------------------------------


Verificar si no hay next demas
Verificar que las rutas vayan de la mas importante a la menos, salvo que se le ponga next
Poner las rutas en carpetas diferentes, todo, así queda mas limpio la app
Agregar una pagina de error personalizado.