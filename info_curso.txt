# Introduction
    Introduction
    What is Node.js?
        
        Runtime
        JS: 
            tipicalmente lo usas en el navegador para manipular el dom.
        Node js: 
            escrito en javascript, te habilita a correr javascript en el servidor, como cualquier otro lenguaje de programación.
            V8, es la maquina de javascript que corre javascript en el navegador, o sea es compilado en lenguaje de maquina.
            O sea, con node js, podes agregar funcionalidad al engine V8, para acceder por ej a archivos.


    Installing Node.js and Creating our First App

        - Crea una carpeta
        - crea un archivo first-app.js
        - enseña como usar fs, o sea, requerirlo para tener acceso al file sistem
            ej: 
                const fs = require('fs');

                fs.writeFileSync('hello.txt', "Hola mundo!");

    Understanding the Role & Usage of Node.js
        
        Explica como el usuario hace una petición, se le devuelven archivos, y aparte con node js, se accede a base de datos, se puede autenticar en otros sitios con oauth, validar inputs, logica de negocio etc.
        Comenta que se puede hacer para hacer mas cosas que esto, scripts, compilar herramientas, etc.

        Se pude crear un servidor que responde a request entrantes, trabajar con db, archivos, etc.
        Responder html, json, xml, archivos, etc.

        Python, PHP, DJIANGO, net core, ETC, son una alternativa a Node js

    Course Outline

        Habla de lo que va del curso, lo saltee, habla de todo eso que se ve en la pantalla.

    How To Get The Most Out Of The Course

        Como sacarle provecho al crso...
            mirar los videos
            codificiar solo y hacer los ejercicios...
            usar los recursos que estan en el curso
            hacer preguntas
            ayudar a otros que hacen preguntas

    Working with the REPL vs Using FIles

        R ead (leer el input del usuario)
        E val (evaluar el input del usuario)
        P rint (output result)
        L oop (esperar por el input)
        
            ejecutar codigo que escribiste
            pa jugar
        vs

        Files:
            usado para hacer aplicaciones reales
            secuencia de pasos.

    Using the Attached Source Code
        
        Explica como usar el codigo que viene en el curso, en ingles, es solo ste texto:

            Using the Attached Source Code
            Sección 1, Clase 8
            Throughout this course, we'll write a lot of code. And to give you the possibility of comparing your code to mine (to find + fix potential errors in your code), you'll find multiple code snapshots per module attached to lectures in this course.

            The last lecture of each module always holds all snapshots for the module, ordered chronologically.

            You can view the code and compare it to yours or replace (parts of) your code with it temporarily (to narrow down the issue).

            How do you use the attached code?

            BEFORE we started using npm, you simply run the main .js file via node - just as we do it in the videos. Or you simply look into the code files to view + compare the code.

            AFTER we started using npm, you need to run npm install inside of the extracted code attachment before you can run npm start to run the server.

------------------------------------------------------------------

# Optional: JavaScript - A Quick Refresher

    
    Module Introduction
    JavaScript in a Nutshell
    Refreshing the Core Syntax
    let & const
    Understanding Arrow Functions
    Working with Objects, Properties & Methods
    Arrays & Array Methods
    Arrays, Objects & Reference Types
    Understanding Spread & Rest Operators
    Destructuring
    Async Code & Promises
    Template Literals
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Understanding the Basics

    Module Introduction

        Como funciona la Web
        Crear un servidor con node js
        usando los modulos core de Nore
        trabajar con request y response        
        codigo asincrono y "the event loop"

    How The Web Works

        Usuario/Cliente (Request) -> 
            Navegador -> 
                entra a una url -> 
                    se busca ese sitio en internet a través de su nombre de dominio ->
                        Tu pagina ( tu codigo )
                            hecho en node js, php, asp .net etc
                            se conecta a base de datos bla.

                        <- Responde tu sitio con headers, html, etc.

        Todo esto se realiza utilizando los protocolos 
        
        HTTP
            Hyper Text Transfer Protocol.
                Como se muestran los request, devuelve las paginas, etc.

        HTTPS
            Hyper Text Transfer Protocol Secure
                HTTP + Data encriptada (durante la transmisión)
                    Para que tu información este segura y estes seguro que nadie este robando la info etc.

    Creating a Node Server
        
        Modulos Core 
            
            http
                Lanza un servidor, envia request, comunicación entre servidores, etc
            https
                Lanza un servior con SSL
            fs
                manejo de archivos
            path
                nos ayuda a manejar los archivos de la solución, o sea la ruta ./ y demas
            os
                nos ayuda con el manejo del sistema operativo.

        Creación del archivo app.js, para crear el servidor en node, con HTTP.

        // Creamos app.js para crear el servidr con node js
        app.js
            const http = require('http'); // Busca por un modulo global llamado http, si hubiera un archivo http, no lo levantaría.
            // import http from 'http'; esto no funciona al menos en la archivo que inicia el servidor.


            const server = http.createServer((req,resp) => {
                console.log(req);
            }); // Va a llamar a la función anonima, para cada request entrante.

            // Le tenemos que decir que escuche, los request entrantes, en un puerto determinado
            server.listen(3000, () => {
                console.log("Servidor corriendo en el puerto: 3000");
            });

    The Node Lifecycle & Event Loop

        node app.js -> 
            start script -> 
                parsea el codigo, registra las variables y funciones ->
                    Se mantiene a la escucha hasta que finalicemos la ejecución del servidor. (Mediante el loop de evento)

        //process.exit(); // Podríamos utilizar esto apra terminar el proceso, pero no tiene sentido stopear un servidor web.

    Controlling the Node.js Process

        Want to quit your running Node.js server?
        You can always do that by pressing CTRL + C in the terminal/ command prompt window where you started your server (i.e. where you ran node app.js).

    Understanding Requests

        console.log(req), vemos Metadatos informados en el request.
            host... headers agregados por el usuario en el request, etc.
            info de cookies, entre mil cosas.


        console.log(req.url);
        console.log(req.method);
        console.log(req.headers);
            GET
            { host: 'localhost:3000',
            connection: 'keep-alive',
            'upgrade-insecure-requests': '1',
            'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',
            accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
            'accept-encoding': 'gzip, deflate, br',
            'accept-language': 'es',
            cookie: '__utmz=111872281.1548878903.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); _ga=GA1.1.270523245.1548878903; __utma=111872281.270523245.1548878903.1548878903.1550705859.2' }
            
        La url es cualquier cosa después de nuestro host, o sea después de la ip (hablando localmente)

    Sending Responses

        response.setHeader('Content-Type','text/html'); // Setea el tipo de respuesta que va a devolver.
        response.write('<html>'); // Escribe multiples lineas de información
        response.write('<head><title>Mi primer pagina</title></head>'); // Escribe multiples lineas de información
        response.write('<body><h1>Hola Mundo</h1></body>'); // Escribe multiples lineas de información
        response.write('</html>'); // Escribe multiples lineas de información
        response.end();

    Request & Response Headers

        On both requests and responses, Http headers are added to transport metadata from A to B.

        The following article provides a great overview of available headers and their role: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers

        Whilst this article is a great resource, especially to dive deeper, please don't learn this list by heart though! You'll encounter many of these headers throughout the course and I'll explain them when we need them.

        
    Routing Requests

        app.js
            const url = request.url;

            if(url === '/'){
                response.write('<html>'); // Escribe multiples lineas de información
                response.write('<head><title>Ingrese un mensaje</title></head>'); // Escribe multiples lineas de información
                response.write('<body><form action="/mensaje" method="POST"><input type="text"><button type="submit">ENVIAR</button></body>'); // Escribe multiples lineas de información
                response.write('</html>'); // Escribe multiples lineas de información
                return response.end(); // El return es para no continuar con la ejecución del codigo
            }

    Redirecting Requests

        app.js
            if(url === '/mensaje' && method === 'POST'){
                
                fs.writeFileSync('mensaje.txt','DUMMY');
                res.statusCode = 302;
                res.setHeader('Location', '/');
                return res.end();
            }

    Parsing Request Bodies
    
        Los datos que vienen por request, son enviados como una "corriente" stream, de datos.
        => Buffer:
            Ej: request incoming ->
                Stream -> info enviada en partes -> Full parsed

            Para organizar estos pedazos de información que vienen de a partes, se usa el buffer.
            El BUFFER es una construcción que te permite trabajar con los multiples pedazos de información antes de ser liberados.

               if(url === '/mensaje' && method === 'POST'){
        
                    // Para trabajar con los pedazos de información que van llegando, 
                    // utilizamos metodos como on, que nos permite escuchar diferentes eventos, en este caso el evento data.
                    const body = [];
                    // El evento data se dispara cuando un nuevo pedazo de información esta listo para ser leido.
                    req.on('data', (chunk) => {
                        console.log(chunk);
                        body.push(); // Pusheamos info en el body;
                    });
                    
                    // Escuchamos el evento end, una vez que se termine de parsear los pedazos de datas del request
                    req.on('end', () => {
                        // Trabajar con el buffer mediante el objeto Buffer que nos provee _Node Js.
                        const parsedBody =  Buffer.concat(body).toString();
                        const mensaje = parsedBody.split('=')[1];
                        fs.writeFileSync('mensaje.txt',mensaje);
                    });

                    //fs.writeFileSync('mensaje.txt','DUMMY');
                    res.statusCode = 302;
                    res.setHeader('Location', '/');
                    return res.end();
            }

    Understanding Event Driven Code Execution

        Explica el orden en el que se   ejecuta el codigo Node js...

    Blocking and Non-Blocking Code

        // Es sincronico, así que bloquea las siguientes ejecuciones.
            fs.writeFileSync('archivo.txt', mensaje);

       // Asincronico 
            fs.writeFile('mensaje.txt', mensaje, (err) => {
                // Deberíamos usar este para leer un archivo grande.
                //fs.writeFileSync('mensaje.txt','DUMMY');
                res.statusCode = 302;
                res.setHeader('Location', '/');
                return res.end();
            });

    Node.js - Looking Behind the Scenes

        Explica que pasa detras de escena.

        Node JS, usa un solo hilo JavaScript (para todos los request)
        
        * VER OTRA VEZ. Lo pase..

    Using the Node Modules System

        Corta todo lo que es de ruteo que estaba en app.js y lo pone en routes.js
        Explica como exportar el modulo y utilizarlo desde otro archivo.

        1) module.exports = nombrefuncion; // puede ser función o un objeto que contenga otros objetos con diferntes cosas.
        2) Shortcut: 
            exports = nombreFuncion;


        routes.js
            EJ 1:
                const requestHandler = (req, res) => {
                    // codigo
                }
                module.exports = requestHandler;

            EJ 2:
                module.exports = {
                    handler: requestHandler,
                    someText: 'Hola soy un texto'
                }

            EJ 3:
                module.exports.handler = requestHandler;
                module.exports.someText =  'Hola soy un texto';

        app.js
            EJ 1:
                const http = require('http'); // Busca por un modulo global llamado http, si hubiera un archivo http, no lo levantaría.
                const routes = require('./routes'); // Como no es un modulo global hay que buscarlo entre los archivos.

                const server = http.createServer(routes); // Maneja a traves de routes, los request entrantes.

            EJ 2:
                const server = http.createServer(routes.handler);
                console.log(routes.someText);

    Wrap Up

        Resumen de todo el modulo.
        
    Time to Practice - The Basics 
        /*
        Tarea:

        1. Levantar un Servidor en el puerto 3000
        2. Manejar 2 rutas "/" y "/usuarios"
            - Devolver algun saludo de bienvenida en /
            - Devolver una lista dummy de usuarios <ul><li>Usuario 1</li><li>Usuario 2</li></ul>
        3. Agregar un formulario con un input username acción / y un boton de submit, metodo POST -> /crear-usuario en el boton
        4. Crear la ruta /crear-usuario y parsear la info entrante, o sea, el username y loguearlo en la consola.

        */

        La hice :)

    Useful Resources & Links

        Attached, you find the source code for this section.

        Useful resources:

        Official Node.js Docs: https://nodejs.org/en/docs/guides/

        Full Node.js Reference (for all core modules): https://nodejs.org/dist/latest/docs/api/

        More about the Node.js Event Loop: https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/

        Blocking and Non-Blocking Code: https://nodejs.org/en/docs/guides/dont-block-the-event-loop/

        Recursos de esta clase
        01-routing-requests.zip
        02-parsing-request-bodies.zip
        03-blocking-and-non-blocking-code.zip
        Ver más (3)
------------------------------------------------------------------

# Improved Development Workflow and Debugging

    Module Introduction
    Understanding NPM Scripts

        npm.org
        1) > npm init
            llenarlo y por ultimo: yes

        2) package.json
            en scripts, agregar start.
            "start": "node app.js"
        
        3) > npm start // para ejecutar ese script

    Installing 3rd Party Packages

        1) Instalar paquetes de 3ros
        2) > npm install nodemon --save-dev
            -g para instalarla globalmente y usarla en todos los repos
            --save-dev // Para que se guarde como dependencia de desarrollo
        3) 
    
    Global Features vs Core Modules vs Third-Party Modules

        The last lectures contained important concepts about available Node.js features and how to unlock them.

        You can basically differentiate between:

        Global features: 
            Keywords like const or function but also some global objects like process

        Core Node.js Modules: 
            Examples would be the file-system module ("fs"), the path module ("path") or the Http module ("http")

        Third-party Modules: 
            Installed via npm install - you can add any kind of feature to your app via this way

        Global features are always available, you don't need to import them into the files where you want to use them.

        Core Node.js Modules don't need to be installed (NO npm install is required) but you need to import them when you want to use features exposed by them.

        Example:

            const fs = require('fs');

            You can now use the fs object exported by the "fs" module.
            Third-party Modules need to be installed (via npm install in the project folder) AND imported.
            
            Example (which you don't need to understand yet - we'll cover this later in the course):

            // In terminal/ command prompt
                npm install --save express-session
            
            // In code file (e.g. app.js)
                const sessions = require('express-session');

    Using Nodemon for Autorestarts

        Explica como funciona nodemon..

    Global & Local npm Packages

        In the last lecture, we added nodemon as a local dependency to our project.

        The good thing about local dependencies is that you can share projects without the node_modules folder (where they are stored) and you can run npm install in a project to then re-create that node_modules folder. This allows you to share only your source code, hence reducing the size of the shared project vastly.

        The attached course code snippets also are shared in that way, hence you need to run npm install in the extracted packages to be able to run my code!

        I showed that nodemon app.js would not work in the terminal or command line because we don't use local dependencies there but global packages.

        You could install nodemon globally if you wanted (this is NOT required though - because we can just run it locally): npm install -g nodemon would do the trick. Specifically the -g flag ensures that the package gets added as a global package which you now can use anywhere on your machine, directly from inside the terminal or command prompt.

    Understanding different Error Types

        Errores de sintaxis
            Cuando le pifias a un ; o lo que sea, se te marca en rojo al toque en el IDE
        
        Errores de compilación
            Cuando se rompe codigo al compilar
        
        Errores Logicos
            No ves un mensaje de error, y son dificles de encontrar
    
    Finding & Fixing Syntax Errors

        Si bien se ven en rojo en la pantalla, también te podes dar cuenta cuando compilas y te dice el error donde esta..

    Dealing with Runtime Errors

        Errores por los cuales por ej, el codigo sigue a una parte que no tenia que seguir.. etc
        También se pueden ver cuando compilas la aplicación

    Logical Errors

        Explica que hay errores que no saltan y te podes volver loco buscandolos, como poner mal un indice bla.
        Explica también un poco de como debugear..

    Using the Debugger

       Explica como usar el debug

    Restarting the Debugger Automatically After Editing our App

          Depurar > Abrir configuraciones

            "program": "${workspaceFolder}\\app.js", // Para que siempre arranque a debuggear desde app
            "restart": true,
            "runtimeExecutable": "nodemon",
            "console": "integratedTerminal"

        Esto sirve para que también se restartee cuando estes debugeando y cambiaste algo.
        Si da error es porque no habíamos instalao nodemon globalmente. 

    Debugging Node.js in Visual Studio Code
    
        Want to dive super-deep into the latest debugging capabilities Visual Studio Code gives you (for Node.js apps)?

        This article will be very helpful: https://code.visualstudio.com/docs/nodejs/nodejs-debugging
        
    
    
    Changing Variables in the Debug Console
    
        Muestra como cambiar una variable en Visual Studio Code, sobretodo como cambiar las constantes.
    
    Wrap Up
        Resumen del modulo.
    Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        More on debugging Node.js: https://nodejs.org/en/docs/guides/debugging-getting-started/

        Debugging Node in Visual Studio Code: https://code.visualstudio.com/docs/nodejs/nodejs-debugging

        Recursos de esta clase
        01-understanding-npm-scripts.zip
        02-using-nodemon-for-autorestarts.zip
        03-finished.zip

------------------------------------------------------------------

# Working with Express.js

    Module Introduction
    What is Express.js?

        Es un framework:
            Funciones de ayuda, herramientas, reglas que te ayudan a contruir tu aplicación.

        Como escribir logica de servidor es compleja, express simplifica esto (lo del buffer x ej)}
        Enforcarnos en lo que realmente importa, como logica de negocios, etc.

        Alternativas a Express:
            Vanilla Node.js (lo que enseñó al principio)
            Adonis.js
            Koa
            Sails.js
            ...

    Installing Express.js

        > npm install express --save // Para instalar en prod

        const express = require('express');

        // Creamos una aplicación y la guardamos en una constante para correr express como una función
        const app = express();

    Adding Middleware

        Middleware:
            Significa que todos los request automaticamente son canalizados a traves de estas funciones por express.
        
        app.use nos permite agregar middleare
 
            app.use((req,res,next) =>{
                // req = request
                // res = response
                // next = ir al siguiente middleware
                
                // console.log("Middleware 1");
                // next();
            });

            // app.use((req,res,next) =>{
            //     console.log("Middleware 2");
            //     //next();
            // });

    How Middleware Works

        res.send('<h1>Hola desde Express</h1>'); // Envia una respuesta
        Por defecto el tipo de respuesta es text/html
    
    Express.js - Looking Behind the Scenes

        Muestra el codigo de Express en Github
        app.list(puerto)
        
    Handling Different Routes
    
        Como rutear con Express.
        Siempre tienen que ir las personalizadas antes que la / porque sino nunca entrarían en esas..
        SALVO QUE SE PONGA NEXT.

    Time to Practice - Express.js 

        Tarea 2:

        1. Crear un proyecto npm e instalar express y nodemon, si queres..
        2. Crear una aplicación express, que tenga 2 request canalizados con middleare que logueen algo en la consola y al menos uno retorne algo
        3. Manejar request para / y /usuarios que cada uno tenga al menos un handler/middleare que haga algo como enviar response dummy


    Parsing Incoming Requests
    
        Por defecto el body no se parsea, es por esto que se usa body-parser

        const bodyParser = require('body-parser');
        
        // urlencoded parsea lo que viene por queryString, no json, para eso se necesita otro.
        // Hay que configurarlo para habilitarlo o no con features especiales.
        app.use(bodyParser.urlencoded({ extended: false}));

        Se obtiene clave/valor.

    Limiting Middleware Execution to POST Requests
    
        En vez de usar app.use se usa:
             app.get
             app.post
             app.put
             app.patch
             ...
             
    Using Express Router
    
        app.js
            const adminRoutes = require('./routes/admin');
            const shopRoutes = require('./routes/shop');

            app.use(adminRoutes);
            app.use(shopRoutes);
        
        admin.js
            const express = require('express');
            const router = express.Router();

            router.get("/add-producto", (req,res) =>{
                //console.log('En otro middleware');
                res.send('<form action="/producto" method="POST"><input type="text" name="title"><button type="submit">Add Product</button></form>'); // Envia una respuesta
            });

            router.post("/producto", (req,res) =>{
                console.log(req.body);
                res.redirect('/');
            });

            module.exports = router;

        shop.js
            const express = require('express');
            const router = express.Router();

            app.use("/", (req,res,next) =>{
                res.send('<h1>Hola desde Express</h1>'); // Envia una respuesta
            });

            module.exports = router;

    Adding a 404 Error Page

        Se agrega la ruta para la pag 404

    Filtering Paths

        Para que los archivos de ruteo no se llmen directamentes así en el navegador:
            ttp://localhost:3000/add-producto
        Sino1:
            http://localhost:3000/admin/add-producto

        app.use('/admin',adminRoutes);
        app.use('/shop',shopRoutes);
    
    Creating HTML Pages
    
        Crear la carpeta views, donde van a estar las vistas de nuestra app
    
    Serving HTML Pages

        shop.js
            const path = require('path');
            res.sendfile( path.join(__dirname, '../','views','shop.html'));

        Returning a 404 Page

            Crea 404.html
            modifica en app: res.status(404).sendFile(path.join(__dirname, 'views', '404.html'));
        
        Using a Helper Function for Navigation

            path.dirname // Retorna el nombre del directorio
            process.mainModule // Se refiere a la ruta principal que arranca la app

        utils/path.js
            const path = require('path');
            module.exports = path.dirname(process.mainModule.filename);

    Styling our Pages
    
        Averiguar que es CSS bem
            Algo asi como, una manera de nomenclar las clases para que no haya repetidas.

    
    Serving Files Statically
    
        crea la carpeta public
        Agregamos a uno de los html:
            <link rel="stylesheet" href="/css/main.css">
        
        app.js
            // Servimos los archivos estaticos a la carpeta public
            app.use(express.static(path.join(__dirname,'public')));

    
    Time to Practice - Navigation 
    
        Tarea 3:

            1. Crear un proyecto npm, instalar Express y Nodemon
            2. Crear un archivo app.js que sirva 2 archivos html (de tu elección con tu contenido)
            3. Agregar algún archivo estatico, css o js al proyecto y que sea requerido en alguno de los archivos html.

            // TO DO
            TAREA PENDIENTE.

    Wrap Up
        Resumen del curso

    Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Express.js Official Docs: https://expressjs.com/en/starter/installing.html

        Recursos de esta clase
        01-adding-middleware.zip
        02-looking-behind-the-scenes.zip
        03-handling-different-routes.zip
        Ver más (11)

------------------------------------------------------------------

# Working with Dynamic Content & Adding Templating Engines

    Module Introduction
    Sharing Data Across Requests & Users
    
        Importar un modulo en otro, para obtener info, ej de adminData -> productos
    
    Templating Engines - An Overview

        HTMLish Template
            HTML
        
        Node/Express Contenido | Maquinas de Templates
            que entienden data como la de productos y la convierten a html 

        Todo esto se compila en el servidor generando un archivo HTML.

        Gratis:
            EJS 
                - Normal HTML y JavaScript plano en los templates
                <p> <%= name %></p>
                
            Pug(Jade) 
                - Use minimal HTML y un lenguaje de template customizado
                p #{name}

            Handlebars
                - Normal HTML y un lenguaje de template customizado
                <p>{{name}}</p>

    Installing & Implementing Pug
    
        - > npm install --save ejs pug express-handlebars
            express-handlebars -> usamos ese porque esta incorporado con Express

        - Los html se tienen que renombrar a .pug

        - Setear en el app que se va a usar un template. Esto no funciona tal cual para todos los templates.

            // Seteo con que template quiero trabajar
            app.set('view engine', 'pug');

            Si tuvieramos las vistas en una carpeta que no se llame views (default de express), deberíamos setearlo así:
            ej: app.use('views','folderVistas');

        shop.pug - Sintaxys
            <!DOCTYPE html>
            html(lang="en")
                head
                    meta(charset="UTF-8")
                    meta(name="viewport", content="width=device-width, initial-scale=1.0")
                    meta(http-equiv="X-UA-Compatible", content="ie=edge")
                    title Document
                body

        - el metodo render lo provee express y se usa para el template que seteamos
            // Le decimos el nombre de la vista y listo, ya que ya habíamos definido el nombre del template a usar.
            res.render('shop');


    Outputting Dynamic Content
    
        Para pasar info a la vista, desde el servidor:
            res.render('shop', { prods: products, docTitle: "Shop" });
        
        En la vista:
            #{docTitle}

            Para recorrer info como productos, pug tiene sus propias funciones 
                each prod in prods
            

    Official Pug Docs

        Want to learn more about Pug? Check out their official docs: https://pugjs.org/api/getting-started.html
    
    Converting HTML Files to Pug

        Hace el resto de los archivos que eran html, pug.
    
    Adding a Layout

        1) En la pagina layout, se ponen los bloques que se importan de cada vista correspondiente

        2) En cada "vista parcial", importa la vista layout, y genera los bloques que corresponden a la vista

            // De esta manera en la vista posta, se "importa" la vista layout
            extends layout/main-layout.pug
            
            // En este bloque se ponen los estilos correspondientes a la vista
            block styles
                link(rel="stylesheet", href="/css/main.css")
                link(rel="stylesheet", href="/css/product.css")
            
            // En este bloque se pone lo que realmente es de la vista.
            block content
                h1 Page Not Found

    Finishing the Pug Template
    
        Como marcar que vista es la activa en la navegación, considerando que ahora tenemos vistas parciales, layout..
            Le pasa el path, en su ruta, y valida eso por codigo, con javascript, que va dentro de parentesis.
                a(href="/shop", class="(path==='/shop' ? 'active' : '')) Shop

    Working with Handlebars
    
        app.engine('handlears',expressHbs());
        app.set('view engine', 'handlebars');

        // También se podría usar así, y así le pones también a las vistas:
        app.engine('hbs',expressHbs());
        app.set('view engine', 'hbs');
    

        En la vista las propiedades se usan así:
        {{ pageTitle }}
        
    Converting our Project to Handlebars
    
        if como este, no es soportado, se tiene que evaluar algo por true o false, 
        por ende esta validación hay que hacerla del lado del servidor y pasarla a la vista.
            {{#if prods.length > 0}}
                //...
            {{ else }}
                //...
            {{/if}}
        

            {{#each prods}}
                //...
                {{ this.title }}
            {{/each}}

        {{# if hasProductos }}

        Esto hace que la logica este del lado del servidor, almenos para handlebars debe trabajarse así, la vista es solo para mostrar cosas.

    
    Adding the Layout to Handlebars

         app.engine('hbs',expressHbs({ layoutsDir: 'views/layouts/',defaultLayout: 'main-layout'}));

         Handlebars no tiene lo que pug (en cuanto al block estilo), hay que poner un bloque if, como si fuera lo de active en pug..
         o sea, mandarselo a la vista y agregarlo si cumple con la condición.

         x ej lo de active se hace así:
            {{#if activeShop}}active{{/if}}

        Se usar para que no tome el layout x default
            en res.render('shop',{layout: false})

            Las vistas que tengna la info dentro de main, son las que van a ser embebidas en la vista layout en la aprte {{body}}

    Working with EJS
    
        No soporta layouts.

        <% if(prods.length > 0 %>

        <% for (let product of prods) { %>

        <% } %>
    Working on the Layout with Partials

         <%- include('includes/navigation.ejs') %>
         <%- include('includes/end.ejs') %>
         
    Wrap Up
    
        Resumen de todo..

    Time to Practice - Templating Engines 
    
        We learned a lot about Pug, Handlebars and EJS so let's see if we know how to use these templating engines now!
        
        Tarea 4: 

            1. Crear un proyecto npm, instalar Express y Nodemon
            2. Agregar 2 rutas:
                "/" -> Tiene un formulario que habilita al usuario a ingresar su nombre
                "/users" -> Tiene una lista con los nombres de usuarios (o algun texto de error)

            // TO DO
            TAREA PENDIENTE. No esuche el video solo anote lo que estaba en pantalla.


    Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Pug Docs: https://pugjs.org/api/getting-started.html

        Handlebars Docs: https://handlebarsjs.com/

        EJS Docs: http://ejs.co/#docs

        Recursos de esta clase
        00-starting-setup.zip
        01-sharing-data-across-requests-and-users.zip
        02-added-pug.zip
        Ver más (4)
------------------------------------------------------------------

# The Model View Controller (MVC) - Sección 7
   
    92 - Module Introduction
    93 - What is the MVC?

        Se trata de una (separation of concerns) separación de preocupaciones.
        Te aseguras que las diferentes partes de tu código hagan cosas diferentes y usted sepa claramente qué parte es responsable de qué. 
        
        MVC significa modelo vista contrlador
        
        Models:
            Son objetos o parte de tu codigo responsable de representar los datos.
            Y te habilita a trabajar con los datos, x ej, guardar, pedir datos (api o bd o archivo)

        Views:
            Por lo que ve el usuario, y renderizar el contenido en el documento.
            Estan desacopladas de el cdigo de tu aplicación y solo tienen pequeños trozos de codigos, necesarios para que la información se muestre al usuario.

        Controladores:
            Son conectores entre el modelo y la vista, porque a la vista no le importa la logica de la aplicación y a los modelos les interesa acerca como guardar la info.
            Los controladores son los que trabajan con los modelos, guardando la información, etc.
            Los controladores son los que trabajan con las vistas, para tomar la información ingresada por el usuario y luego llamar al modelo para guardar.

            Es un intermediario que tiene logica intermediaria.

            También define con que modelo y vista se debe trabajar para hacer determinada acción.

        Rutas?: 
            Definen en que ruta encontrar tanto los metodos de los controladores como los metodos http que necesitamos

        
    94 - Adding Controllers
    
        A lo que se llama "logica intermediaria" del controlador, es a la parte del middlewareque se utiliza entre que se llama a la ruta necesaria y lo que retorna.
        Podes crear difrentes tipos de controladores, por ej adminController, productController, userController, y en cada uno manejar lo necesario para ese concepto.
        x ej, si bien antes habíamos puesto /shop por otro lado, es parte de productos, porque lo que compras, es eso.

        O sea, lo que hacemos es, en index, decir que la ruta x ej /admin va a usar información del archivo de ruteo de admin, por otro lado en las rutas, 
        pongo el codigo de los diferentes metodos en el controlador de productos, y aca solo utilizo el controlador
    
    95 - Finishing the Controllers
    
        El use de la pagina de error, lo deja en el index del server, importa el controlador error que creó, mete su logica intermediaria ahí y usa eso.
        
    96 - Adding a Product Model
    
        Basicamente una o varias clases que representen a los tipos de objetos con los que vamos a estar trabajando y con sus difentes metodos.
        
        Propiedades
            del objeto

        Metodos:
            save
            get(id)
            getAll
            delete
            static fetchAll() // Lo pone estatico porque sino se tendría que crear un objeto solo para obtener algo que debería estar cargado si necesidad justamente de crear un objeto nuveo

        Después en los respectivos contorladores llamamos a nuestro modelo y lo utilizamos segun correspnda.

    97 - Storing Data in Files Via the Model
    
        Agrega una carpeta de data, para mostrar esto.
        En el modelo en la parte de guardar, genera el codigo para escribir el archivo. 
            Ver ejemplo en carpeta 97

        fs.readFile(archivo, (error, contenidoDeArchivo) =>{
            
        })

        JSON.parse // parsea el objeto en un Array
        JSON.stringify // convierte el array enjso
            
    98 - Fetching Data from Files Via the Model
    
        Como la función es estatica y se ejecuta ni bien se inicia, porque eso pasa con las clases estaticas, no es necesario llamarlas porque ya estan cargadas.
        el codigo se ejecuta asincronico (fs.readFile) que no lee el archivo de manera inmediata sino que registra el callback y termina la función, por eso se devuelve un array vacio.

        Para solucionar esto:
            Por el momento se le agrega un argumento a la función, un callback, entonces esto se va a llamar cuando readFile termine y se cierre la ejecución de fetchAll
            
            static fetchAll(cb){

                Se modifica el return []; por cb([]);
            }

            Idem por si no hay un error, parseamos el contenido del array en el json. y lo devolvemos.
            Por ultimo se modifica el getProductos, para renderizar en la parte del callback
                Ver ejemplo en carpeta 98 

    99 - Refactoring the File Storage Code
    
        Modifica codigo repetivo en una función helper que obtiene el archivo y reemplaza eso donde se estaba reptiendo el codigo.
    
    100 - Wrap Up

        Resumen
    
    101 - Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        More on MVC: https://developer.mozilla.org/en-US/docs/Glossary/MVC

        Recursos de esta clase
        00-starting-setup.zip
        01-finished-the-controller.zip
        02-adding-a-product-model.zip
        Ver más (2)

------------------------------------------------------------------

# Optional: Enhancing the App
    Module Introduction

        Practicar lo que se aprendió agregando info al proyecto, es opcional este modulo.
    
    Creating the Shop Structure
    Working on the Navigation
    Registering the Routes
    Storing Product Data
    Displaying Product Data
    Editing & Deleting Products
    Adding Another Item
    Useful Resources & Links

------------------------------------------------------------------

# Dynamic Routes & Advanced Models - Sección 9
    113 - Module Introduction
    
        Aprender sobre 
            como pasar parametros a las rutas, 
            como usar parametros por querystrnig 
            mejorar los modelos

    114 - Preparations
    
            Como nos salteamos el modulo anterior, hay que usar su proyecto.
            Voy a backapear todo y poner lo que puso el.

    115 - Applied Changes
    
        What changed in the attached files?
        Basically, a mobile navigation (for smaller/ mobile screens) was added. Besides that, only minor things were fixed.
    
    116 - Adding the Product ID to the Path

        Agregó al detalle del producto en la vista, el id para cuando hiciera click 
            /product/<%= product.id %>

        Agrego al archivo que simula ser bd, el id para los que ya tendría
        Agregó al guardar por ahora un id random con math.
    
    117 - Extracting Dynamic Params
    
        Con los : se le dice a Express que no busque una ruta sino un parametro
        
            /product/:produtId
        
        * Siempre estas rutas deben ir como ultima opción.

    118 - Loading Product Detail Data

        Crear una función estatica findById(id,cb), que obtiene la info del archivo y busca el id en particular que se le pasa por parametro.
        recorriendo los productos.
            products.find(p => { pd.id == id });
    
    119 - Rendering the Product Detail View
    
        Genera la vista detalle de producto y usa las diferentes propiedades del objecto para mostrar la info
        en el controlador renderiza la visa y pasa el producto.
    
    120 - Passing Data with POST Requests 

        En el html tiene que estar el atributo name, porque sino no se reconoce como parametro
        Si queres usar un include y justo esta dentro de un for y utiliza una propiedad del for, hay que pasarselo como segundo parametro.
        <%- include('.../includes/add-to-cart.ejs', {product: product}) %>

    121 - Adding a Cart Model

        Crea el modelo Cart, no crea instancias nuevas, porque carrito hay solo 1.
        Ver ese video otra vez.

    122 - Using Query Params
    
        Pasar parametros por queryString y recuperarlos.

    123 - Pre-Populating the Edit Product Page with Data
    
        Obtener un producto especifico por get para editarlo
    
    124 - Linking to the Edit Page
    
        llamar a la pagina de edición con el parametro por querystring del id del producto y editar en true

    125 - Editing the Product Data
    
        ruta para poder editarlo, modificaciones para poder obtener ese producto en particular y luego pisarlo con las modificaciones que se le hicieron

    126 - Adding the Product-Delete Functionality
    
        Generación del metodo eliminaren el modelo
    
    127 - Deleting Cart Items
    
        Agrega a la clase de cart un metodo para eliminar el producto del carrito

    127 - Displaying Cart Items on the Cart Page

        Genera una nueva vista para la parte de Cart, donde se van agregando los productos al carrito
    
    128 - Deleting Cart Items
    
        agrega el boton para eliminar, el html con el onlick para que vaya a la ruta correspondiente de eliminar, hacemos la ruta para eso tambien.
        elimina el producto x el id.

    130 - Fixing a Delete Product Bug
    
        arregla un bug quehabía

    131 - Wrap Up
    
        Resumen

    132 - Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resources:

        Official Routing Docs: https://expressjs.com/en/guide/routing.html

        Recursos de esta clase
        00-starting-setup.zip
        01-extracting-dynamic-params.zip
        02-loading-product-detail-data.zip
        Ver más (7)
------------------------------------------------------------------

# SQL Introduction
    
    133 - Module Introduction
         
         Aprender sobre: 
            Base de datos, que te ayudan a guardar y obtener datos.
            Sobre las distintas bd, SQL y NoSQL.
            Que tipo de base de dato es mejor para tu aplicación..

    134 - Choosing a Database

        Diferencias entre SQL y NoSQL
            Tener en cuenta siempre nuestra meta: guardar datos y que sean facilmente accesibles.
            Una bd es mas facil y rapida que usar un archivo, ya que a medida que crece un archivo ocuparia mas espacio en memoria.
                - Aparte no tenemos que leer todo el archivo para encontrar un pedazo de información.

            Tipos:
                SQL, ej:
                    - MySQL.

                NoSQL, ej:
                    - MongoDB

            SQL Database:
                - Pensar en "tablas"
                    - Tenemos campos/columnas con diferentes información que necesitamos.
                    - Cada fila (row), es un registro de información especifico.
                    Ej una tabla de usuarios, cada usuario es un registro.
                    - Cada tabla la podemos relacionar con otra trabla, ej productos con ordenes.

            Core SQL Database Caracteristicas:
                - Esquema de datos:
                    Un esquema bien definido sobre que información queremos de los datos en su tabla correspondiente y sus diferentes tipos.

                - Relaciones.
                    Relaciones entre tablas con tipos diferentes de relación:
                        - Uno a uno.
                        - Uno a muchos.
                        - Muchos a muchos.

            SQL: Structure query languaje. (Lenguaje de consulta estructurado).
                - Las consultas (queries) son comandos que usamos par interactuar con la base de datos, x ej: SELECT * FROM users WHERE age > 28
                - Tiene sintaxis especifica con (select, from, where, etc) con diferentes parametros (*, nombre de tabla, nombre de columna, num a buscar, etc)
                - 

    135 - NoSQL Introduction

         NoSQL (simplemente significa eso, no es un lenguaje estructurado de consultas), no se enfoca en esquemas.

         Seguimos teniendo una base de datos, por ej Shop:
            - Acá no tenemos tablas, sino COLECCIONES.
            - No buscamos records (registros), sino, DOCUMENTOS.
                Estos documentos son muy parecidos a la manera en la que describimos objetos en JS.
            - No tiene un esquema estricto.
                x ej: tenemos 2 documentos en nuestra colección, que uno tiene solamente nombre y el otro nombre y edad.
            - No tenemos relaciones reales, a cambio, estamos duplicando información. Por ej:
                Tenemos los datos del usuario que a su vez en la colección de ordenes, es un documento separado con mas detalles y no están conectados por ningún dato. Simplemente duplicamos la información.
                El tema es que si necesitamos actualizar la información, al tenemos que ACTUALIZAR EN MULTIPLES LUGARES, si realmente lo necesitan todos, aunque no tenemos que andar haciendo joins y demases, que pueden impactar en la performances.
            - Es muy rapida y eficas.
        
        No SQL, Caracteristicas:
            - No tenemos un esquema estricto, podemos mezclar datos en la misma colección.
            - No tenemos relaciones. Podemos relacionar datos de alguna manera, lo vamos a ver mas adelante. Generalmente vamos a tener NINGUNA o UNAS POCAS conecciones.

    136 - Comparing SQL and NoSQL

        Escalamiento vertical vs horizontal:

        Horizontal (SQL):
            Agregamos mas servidores.
            Mergeamos los datos en una bd.
            Es muy dificil y a veces imposible escalar, por la manera en que funciona sql, si bien podes agregar mas servidores, y compartir la info de todos en uno pero es muy dificil.

        Vertical (NoSQL):
            A un único servidor se le agrega mas cpu, memoria, etc. Con cloud es re facil hacer esto.
            Es facil de escalar.
         
        Elegir siempre del tipo de información que estamos guardando y si realmente es necesario que tenga relaciones.  

    137 - Setting Up MySQL

        Instalar eligiendo solo MySQL Server y MySQL Workbench
        Elegir legacy password: gia..
        Chequear para que arranque una vez que se termine de instalar.
        Clic en la instancia local > 
            poner el pass -> 
                crear un nuevo squema > "node-complete", dejar los checks como estan.

    138 - Connecting our App to the SQL Database
        
        1) npm install --save mysql2
        2) Crear un archivo dentro de la carpeta utils: database.js
            Importar el paquete mysql2.
            Como conectarnos a la base de datos.  
            - Definimos crear un pool para que se manejen todas las queries, ya que no queremos una conección sola sino un pool de conexiones.
            - Definimos:
                - host (como va a correr por ahora en nuestra pc es localhost)
                - user (por default es root)
                - database ("no-complete")
                - password: la que se uso en la instalación

            const pool = mysql.createPool({
                host: 'localhost',
                user: 'root',
                database: 'node-complete',
                password: 'password'    
            });

            module.exports = pool.promise(); // Trabajar con promesas, nos va a permitir  manejar tasks, ya que es asincronico, en vez de cb.

            app.js
                importamos el archivo en una constante y de esta manera nos va a ayudar a manejar el pool de conecciones:

                const db = require('./util/database');

                db.execute('SELECT * FROM products');

            MySQL:
                Creamos la tabla productos.

    139 - Basic SQL & Creating a Table

        Creamos las columnas con su tipo. > apply
        Creamos un registro dummy > apply
        db.execute('SELECT * FROM products').then().catch();

    140 - Retrieving Data

        .then y .catch son funciones que encadenamos al resultado de nuestra llamada a la base.

        Promesa nos habilita a escribir codigo mas estructurado, en vez de tener una cb function como segundo argumento, simplemente tenemos:
        - then que es una función anonima que se ejecuta después de la llamada.
        - catch, toma cualquier error que pase.

        db.execute('SELECT * FROM products')
        .then((result) => {
            console.log(result);
        })
        .catch(err => {
            console.log(err);
        });


    141 - Fetching Products
        Eliminamos todo lo relacionado al archivo en productos.
        importamos nuestro pool.
        en shop modificamos la cb por la promesa 

        Tarea: Arreglar products.

    142 - Fetching Products - Time to Practice  
        Muestra como arreglar products (como en shop index)

    143 - Inserting Data Into the Database
        en Save() de products.
        db.execute('INSERT INTO productos (title, price, imageUrl, description) VALUES (?,?,?,?)',
        [this.title, this.price, this.imageUrl, this.description]);

        los signos de ? son para evitar injección de sql.

        Esto retorna una promesa, así que ahora actualizamos el save en admin.

    144 - Fetching a Single Product with the "where" Condition
        Tener en cuenta que cuando se obtienen datos de la base se obtienen como array, entonces si queremos pasar un solo producto, tenemos que pasar product[0], sino se rompe la vista.

    145 - Wrap Up
       
        Explica que se puede terminar el proyecto pero se va a llenar de queries.
        En vez de llenar todo de queries, va a enseñar como usar sequelize.

    146 - Useful Resources & Links

        Attached, you find the source code for this section.

        When using my source code, make sure to run npm install in the extracted folder!

        Useful resource:

        Learn more about MySQL/ SQL in General: https://www.w3schools.com/sql/

        Learn more about the Node MySQL Package: https://github.com/sidorares/node-mysql2

        Recursos de esta clase
        00-starting-setup.zip
        01-connecting-our-app.zip
        02-fetching-products-time-to-practice.zip
        03-inserting-data.zip
        04-fetching-a-single-product.zip
------------------------------------------------------------------

# Understanding Sequelize
    
    147 - Module Introduction
        bla bla Sequelize

    148 - What is Sequelize?

        Es un paquete de terceros, un mapper de data. (third party package) ORM
        Object
        Relational
        Mapping 
        Library

        Todo el SQL Code, lo mapea en JS objects detras de escena con metodos especificos que llamemos para ejecutar.

        En vez de escribir código escribimos js, como:

        const user = User.create({ name: 'Max', age: 32 })

        Nos ofrece:
            - Modelos -> User, Product
            - Instancias de estos modelos. -> const user = User.build()
            - Queries -> User.findAll()
            - Asociar, nuestros modelos -> User.hasMany(Product)

    149 - Connecting to the Database

        1) Instalar sequelize
            npm install --save sequelize // es una 
            dependencia de prod.

        2) Eliminamos la base de datos. (Porque ahora lo vamos a manejar con sequelize.)
        3) util.js:
            Creamos la conexión con la base de datos. 
            Eliminamos todo lo relacionado a mysql.
            // Se pone con mayus porque importa función de construcción.

            const Sequelize = require('sequelize');

            const sequelize = new Sequelize('node-complete','root','$gia.69$', {dialect: 'mysql', host: 'localhost'});

            * host no es necesario ponerlo cuando es localhost, pero se puede poner igual.
        
    150 - Defining a Model
        
        Elimina todo lo que hay en models>produt
            importar sequelize
            importo mi db desde utils

    151 - Syncing JS Definitions to the Database
    152 - Inserting Data & Creating a Product
    153 - MUST READ: findById() in Sequelize 5
    154 - Retrieving Data & Finding Products
    155 - Getting a Single Product with the "where" Condition
    156 - Fetching Admin Products
    157 - Updating Products
    158 - Deleting Products
    159 - Creating a User Model
    160 - Adding a One-To-Many Relationship
    161 - Creating & Managing a Dummy User
    162 - Using Magic Association Methods
    163 - Fetching Related Products
    164 - One-To-Many & Many-To-Many Relations
    165 - Creating & Fetching a Cart
    166 - Adding New Products to the Cart
    167 - Adding Existing Products & Retrieving Cart Items
    168 - Deleting Related Items & Deleting Cart Products
    169 - Adding an Order Model
    170 - Storing Cartitems as Orderitems
    171 - Resetting the Cart & Fetching and Outputting Orders
    172 - Wrap Up
    173 - Useful Resources & Links

------------------------------------------------------------------

# Working with NoSQL & Using MongoDB

    Module Introduction
    What is MongoDB?
    Relations in NoSQL
    Setting Up MongoDB
    Installing the MongoDB Driver
    Creating the Database Connection
    Finishing the Database Connection
    Using the Database Connection
    Creating Products
    Understanding the MongoDB Compass
    Fetching All Products
    Fetching a Single Product
    Making the "Edit" & "Delete" Buttons Work Again
    Working on the Product Model to Edit our Product
    Finishing the "Update Product" Code
    One Note About Updating Products
    Deleting Products
    Fixing the "Add Product" Functionality
    Creating New Users
    Storing the User in our Database
    Working on Cart Items & Orders
    Adding the "Add to Cart" Functionality
    Storing Multiple Products in the Cart
    Displaying the Cart Items
    Fixing a Bug
    Deleting Cart Items
    Adding an Order
    Adding Relational Order Data
    Getting Orders
    Removing Deleted Items From the Cart
    Wrap Up
    Useful Resources & Links
    Two Adjustments (behind the scenes)

------------------------------------------------------------------

# Working with Mongoose

    Module Introduction
    What is Mongoose?
    Connecting to the MongoDB Server with Mongoose
    Creating the Product Schema
    Saving Data Through Mongoose
    Fetching All Products
    Fetching a Single Product
    Updating Products
    Deleting Products
    Adding and Using a User Model
    Using Relations in Mongoose
    One Important Thing About Fetching Relations
    Working on the Shopping Cart
    Loading the Cart
    Deleting Cart Items
    Creating & Getting Orders
    Storing All Order Related Data
    Clearing the Cart After Storing an Order
    Getting & Displaying the Orders
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Sessions & Cookies

    Module Introduction
    What is a Cookie?
    The Current Project Status
    Optional: Creating the Login Form
    Adding the Request Driven Login Solution
    Setting a Cookie
    Manipulating Cookies
    Configuring Cookies
    What is a Session?
    Initializing the Session Middleware
    Using the Session Middleware
    Using MongoDB to Store Sessions
    Sessions & Cookies - A Short Summary
    Time to Practice - Sessions and Cookies 
    1 pregunta
    Deleting a Cookie
    Fixing Some Minor Bugs
    Making "Add to Cart" Work Again
    Two Tiny Improvements
    Wrap Up
    Code Adjustments
    Useful Resources & Links

------------------------------------------------------------------

# Adding Authentication

    Module Introduction
    What is Authentication?
    How is Authentication Implemented?
    Our Updated Project Status
    Implementing an Authentication Flow
    Encrypting Passwords
    Adding a Tiny Code Improvement
    Adding the Signin Functionality
    Working on Route Protection
    Using Middleware to Protect Routes
    Understanding CSRF Attacks
    Using a CSRF Token
    Adding CSRF Protection
    Fixing the Order Button
    Providing User Feedback
    Optional: Styling Error Messages
    Finishing the Flash Messages
    Adding Additional Flash Messages
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Sending Emails

    Module Introduction
    How Does Sending Emails Work?
    Using SendGrid
    Using Nodemailer to Send an Email
    Potential Limitation for Large Scale Apps
    Useful Resources & Links

------------------------------------------------------------------

# Advanced Authentication

    Module Introduction
    Resetting Passwords
    Implementing the Token Logic
    Creating the Token
    Creating the Reset Password Form
    Adding Logic to Update the Password
    Why we Need Authorization
    Adding Authorization
    Adding Protection to Post Actions
    Why Editing Fails
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Understanding Validation

    Module Introduction
    Why Should We Use Validation?
    How to Validate Input?
    Setup & Basic Validation
    Using Validation Error Messages
    Built-In & Custom Validators
    More Validators
    Checking For Field Equality
    Adding Async Validation
    Time to Practice - Validation 
    1 pregunta
    Keeping User Input
    Adding Conditional CSS Classes
    Adding Validation to Login
    Sanitizing Data
    Validating Product Addition
    Validating Product Editing
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Error Handling

    Module Introduction
    Types of Errors & Error Handling
    Analyzing the Error Handling in the Current Project
    Errors - Some Theory
    Throwing Errors in Code
    Returning Error Pages
    Using the Express.js Error Handling Middleware
    Updating the App
    Using the Error Handling Middleware Correctly
    Status Codes
    Available Status Codes
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# File Upload & Download

    Module Introduction
    Adding a File Picker to the Frontend
    Handling Multipart Form Data
    Handling File Uploads with Multer
    Configuring Multer to Adjust Filename & Filepath
    Filtering Files by Mimetype
    Storing File Data in the Database
    Remove imageUrl from "Add Product"
    Serving Images Statically
    Downloading Files with Authentication
    Setting File Type Headers
    Restricting File Access
    Streaming Data vs Preloading Data
    Using PDFKit for .pdf Generation
    Generating .pdf Files with Order Data
    Deleting Files
    Fixing Invoice Links
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Adding Pagination

    Module Introduction
    Adding Pagination Links
    Retrieving a Chunk of Data
    Skip & Limit with SQL
    Preparing Pagination Data on the Server
    Adding Dynamic Pagination Buttons
    Re-Using the Pagination Logic & Controls
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Understanding Async Requests

    Module Introduction
    What are Async Requests?
    Adding Client Side JS Code
    The JSON Data Format
    Sending & Handling Background Requests
    Manipulating the DOM
    Useful Resources & Links

------------------------------------------------------------------

# Adding Payments

    Module Introduction
    How Payments Work
    Adding a Checkout Page
    Using Stripe in Your App
    Useful Resources & Links

------------------------------------------------------------------

# Working with REST APIs - The Basics
    
    Module Introduction
    What are REST APIs and why do we use Them?
    Accessing Data with REST APIs
    Understanding Routing & HTTP Methods
    REST APIs - The Core Principles
    Creating our REST API Project & Implementing the Route Setup
    Sending Requests & Responses and Working with Postman
    REST APIs, Clients & CORS Errors
    Sending POST Requests
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Working with REST APIs - The Practical Application

    Module Introduction
    REST APIs & The Rest Of The Course
    Understanding the Frontend Setup
    Planning the API
    Fetching Lists of Posts
    Adding a Create Post Endpoint
    Adding Server Side Validation
    Setting Up a Post Model
    Storing Posts in the Database
    Static Images & Error Handling
    Fetching a Single Post
    Image Names & Windows
    Uploading Images
    Updating Posts
    Deleting Posts
    Adding Pagination
    Adding a User Model
    Adding User Signup Validation
    Signing Users Up
    How Does Authentication Work?
    Starting with User Login
    Logging In & Creating JSON Web Tokens (JWTs)
    Using & Validating the Token
    Adding Auth Middleware to All Routes
    Connecting Posts & Users
    Adding Authorization Checks
    Clearing Post-User Relations
    Time to Practice - Working with REST APIs 
    1 pregunta
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Understanding Async Await in Node.js

    Module Introduction
    What is Async Await All About?
    Transforming "Then Catch" to "Async Await"
    Time to Practice - Async Await 
    1 pregunta
    The User Name is Missing!
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Understanding Websockets & Socket.io

    Module Introduction
    What Are Websockets & Why Would You Use Them?
    Websocket Solutions - An Overview
    Setting Up Socket.io on the Server
    Establishing a Connection From the Client
    Identifying Realtime Potential
    Sharing the IO Instance Across Files
    Synchronizing POST Additions
    Fixing a Bug - The Missing Username
    Updating Posts On All Connected Clients
    Sorting Correctly
    Deleting Posts Across Clients
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Working with GraphQL

    Module Introduction
    What is GraphQL?
    Understanding the Setup & Writing our First Query
    Defining a Mutation Schema
    Adding a Mutation Resolver & GraphiQL
    Adding Input Validation
    Handling Errors
    Connecting the Frontend to the GraphQL API
    Adding a Login Query & a Resolver
    Adding Login Functionality
    Adding a Create Post Mutation
    Extracting User Data From the Auth Token
    Sending the "Create Post" Query
    Fixing a Bug & Adding New Posts Correctly
    Adding a "Get Post" Query & Resolver
    Sending "Create Post" and "Get Post" Queries
    Adding Pagination
    Uploading Images
    Fetching the imageUrl
    Viewing a Single Post
    Updating Posts
    Deleting Posts
    Adding Posts & Pagination
    Managing the User Status
    Using Variables
    Fixing a Pagination Bug
    Wrap Up
    Useful Resources & Links

------------------------------------------------------------------

# Deploying our App

    Module Introduction
    Deploying Different Kinds of Apps
    Deployment Preparations
    Using Environment Variables
    Using Production API Keys
    Setting Secure Response Headers with Helmet
    Compressing Assets
    Setting Up Request Logging
    More on Logging
    Setting Up a SSL Server
    Using a Hosting Provider
    Understanding the Project & the Git Setup
    A Deployment Example with Heroku
    Storing User-generated Files on Heroku
    Deploying APIs
    Useful Resources & Links

------------------------------------------------------------------

# Node.js as a Build Tool & Using npm

    Module Introduction
    npm & Node.js
    Using npm
    Versioning in package.json
    What is a Build Tool?
    Using Node.js in Build Processes
    Useful Resources & Links

------------------------------------------------------------------

# Roundup
    Course Roundup
    Course Slides
    Bonus: More Content!



-------------------- IDEAS BELGA ---------------------------------


Verificar si no hay next demas
Verificar que las rutas vayan de la mas importante a la menos, salvo que se le ponga next
Poner las rutas en carpetas diferentes, todo, así queda mas limpio la app
Agregar una pagina de error personalizado.